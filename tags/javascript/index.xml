<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on nodejh</title>
    <link>http://nodejh.com/tags/javascript/index.xml</link>
    <description>Recent content in Javascript on nodejh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="http://nodejh.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Is JavaScript a call by reference or call by value language?</title>
      <link>http://nodejh.com/post/Is-JavaScript-a-pass-by-reference-or-pass-by-value-language/</link>
      <pubDate>Sat, 18 Feb 2017 11:07:14 +0800</pubDate>
      
      <guid>http://nodejh.com/post/Is-JavaScript-a-pass-by-reference-or-pass-by-value-language/</guid>
      <description>

&lt;h2 id=&#34;1-例子&#34;&gt;1. 例子&lt;/h2&gt;

&lt;p&gt;先来看两个个来自于 《JavaScript 高级程序设计》P70-P71 的两个例子。&lt;/p&gt;

&lt;h4 id=&#34;1-1-基本类型参数传递&#34;&gt;1.1. 基本类型参数传递&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function addTen(num) {
  num += 10;
  return num;
}

var count = 20;
var result = addTen(count);
alert(count); // 20, 没有变化
alert(result); // 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;书上解释说，JavaScript 参数传递都是按值传参。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以传递给 &lt;code&gt;addTen&lt;/code&gt; 函数的值是 &lt;code&gt;20&lt;/code&gt; 这个值，所以函数执行结束原始变量 &lt;code&gt;count&lt;/code&gt; 并不会改变。&lt;/p&gt;

&lt;h4 id=&#34;1-2-引用类型参数传递&#34;&gt;1.2. 引用类型参数传递&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function setName(obj) {
  obj.name = &#39;Nicholas&#39;;
  obj = new Object();
  obj.name = &#39;Greg&#39;;
}

var person = new Object();
setName(person);
alert(person.name); // Nicholas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么结果是 &lt;code&gt;Nicholas&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2017-02-17-Is-JavaScript-a-pass-by-reference-or-pass-by-value-language-1.png&#34; alt=&#34;变量存储方式&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;疑问：如果是传值，那应该是把 person 变量的值（也就是一个指向堆内存中对象的指针）传递到函数中，&lt;code&gt;obj.name = &#39;Greg&#39;;&lt;/code&gt; 改变了堆内存中对象的属性，为什么 &lt;code&gt;person.name&lt;/code&gt; 还是 &lt;code&gt;Nicholas&lt;/code&gt; ？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-传值还是传引用&#34;&gt;2. 传值还是传引用？&lt;/h2&gt;

&lt;p&gt;让我们再将上面两个例子综合为下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function changeStuff(a, b, c) {
  a = a * 10;
  b.item = &amp;quot;changed&amp;quot;;
  c = {item: &amp;quot;changed&amp;quot;};
}

var num = 10;
var obj1 = {item: &amp;quot;unchanged&amp;quot;};
var obj2 = {item: &amp;quot;unchanged&amp;quot;};

changeStuff(num, obj1, obj2);

console.log(num);
console.log(obj1.item);    
console.log(obj2.item);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的输出结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10
changed
unchanged
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以 JS 到底是传值调用还是传引用调用呢？要弄清楚这个问题，首先我们要明白到底什么是&lt;strong&gt;传值调用（Call-ny-value）&lt;/strong&gt;和&lt;strong&gt;传引用调用（Call-by-reference）&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;2-1-传值调用-pass-by-value&#34;&gt;2.1. 传值调用（Pass by value）&lt;/h4&gt;

&lt;p&gt;在传值调用中，传递给函数参数是函数被调用时所传实参的拷贝。在传值调用中实际参数被求值，其值被绑定到函数中对应的变量上（通常是把值复制到新内存区域）。&lt;/p&gt;

&lt;p&gt;即 &lt;code&gt;changeStuff&lt;/code&gt; 的参数 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;num1&lt;/code&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 的拷贝。所以无论 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 怎么变化，&lt;code&gt;num1&lt;/code&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 都保持不变。&lt;/p&gt;

&lt;p&gt;问题就在于 &lt;code&gt;obj1&lt;/code&gt; 变了。&lt;/p&gt;

&lt;h4 id=&#34;2-2-传引用调用-pass-by-reference&#34;&gt;2.2. 传引用调用（Pass by reference）&lt;/h4&gt;

&lt;p&gt;在传引用调用调用中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。通常函数能够修改这些参数（比如赋值），而且改变对于调用者是可见的。&lt;/p&gt;

&lt;p&gt;也就是说 &lt;code&gt;changeStuff&lt;/code&gt; 函数内的 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 都分别与 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 指向同一块内存，但不是其拷贝。函数内对 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 所做的任何修改，都将反映到 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 上 。&lt;/p&gt;

&lt;p&gt;问题就在于 &lt;code&gt;num&lt;/code&gt; 和 &lt;code&gt;obj2&lt;/code&gt; 没变。&lt;/p&gt;

&lt;p&gt;从上面的代码可以看出，JavaScript 中函数参数的传递方式既不是传值，也不是传引用。主要问题出在 JS 的引用类型上面。&lt;/p&gt;

&lt;p&gt;JS 引用类型变量的值是一个指针，指向堆内存中的实际对象。&lt;/p&gt;

&lt;h4 id=&#34;2-3-传共享调用-call-by-sharing&#34;&gt;2.3. 传共享调用（Call by sharing）&lt;/h4&gt;

&lt;p&gt;还有一种求值策略叫做&lt;a href=&#34;http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/#call-by-sharing&#34;&gt;传共享调用（Call-by-sharing/Call by object/Call by object-sharing）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;传共享调用和传引用调用的不同之处是，该求值策略传递给函数的参数是对象的引用的拷贝，即对象变量指针的拷贝。&lt;/p&gt;

&lt;p&gt;也就是说， &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 三个变量的值是 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 的指针的拷贝。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 的值分别与 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 的值指向同一个对象。函数内部可以对  &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 进行修改可重新赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function changeStuff(a, b, c) {
  a = a * 10; // 对 a 赋值，修改 a 的指向，新的值是 a * 10
  b.item = &amp;quot;changed&amp;quot;; // 因为 b 与 obj1 指向同一个对象，所以这里会修改原始对象 obj1.item 的内容
  c = {item: &amp;quot;changed&amp;quot;}; // 对 c 重新赋值，修改 c 的指向，其指向的对象内容是 {item: &amp;quot;changed&amp;quot;}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-代码分析&#34;&gt;3 代码分析&lt;/h2&gt;

&lt;p&gt;接下来让我们再来分析一下代码。&lt;/p&gt;

&lt;h4 id=&#34;3-1-变量初始化&#34;&gt;3.1 变量初始化&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var num = 10;
var obj1 = {item: &amp;quot;unchanged&amp;quot;};
var obj2 = {item: &amp;quot;unchanged&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2017-02-19-Is-JavaScript-a-pass-by-reference-or-pass-by-value-language-2.png&#34; alt=&#34;变量初始化&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-2-调用函数&#34;&gt;3.2 调用函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;changeStuff(num, obj1, obj2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2017-02-19-Is-JavaScript-a-pass-by-reference-or-pass-by-value-language-3.png&#34; alt=&#34;调用函数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，变量 &lt;code&gt;a&lt;/code&gt; 的值就是 &lt;code&gt;num&lt;/code&gt; 值的拷贝，变量 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; 分别是 &lt;code&gt;obj1&lt;/code&gt; &lt;code&gt;obj2&lt;/code&gt; 的指针的拷贝。&lt;/p&gt;

&lt;p&gt;函数的参数其实就是函数作用域内部的变量，函数执行完之后就会销毁。&lt;/p&gt;

&lt;h4 id=&#34;3-3-执行函数体&#34;&gt;3.3 执行函数体&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;a = a * 10;
b.item = &amp;quot;changed&amp;quot;;
c = {item: &amp;quot;changed&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2017-02-19-Is-JavaScript-a-pass-by-reference-or-pass-by-value-language-5.png&#34; alt=&#34;执行函数体&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，变量 &lt;code&gt;a&lt;/code&gt; 的值的改变，并不会影响变量 &lt;code&gt;num&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;b&lt;/code&gt; 因为和 &lt;code&gt;obj1&lt;/code&gt; 是指向同一个对象，所以使用 &lt;code&gt;b.item = &amp;quot;changed&amp;quot;;&lt;/code&gt; 修改对象的值，会造成 &lt;code&gt;obj1&lt;/code&gt; 的值也随之改变。&lt;/p&gt;

&lt;p&gt;由于是对 &lt;code&gt;c&lt;/code&gt; 重新赋值了，所以修改 &lt;code&gt;c&lt;/code&gt; 的对象的值，并不会影响到 &lt;code&gt;obj2&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;4-结论&#34;&gt;4. 结论&lt;/h2&gt;

&lt;p&gt;从上面的例子可以看出，对于 JS 来说：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本类型是传值调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用类型传共享调用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传值调用本质上传递的是变量的值的拷贝。&lt;/p&gt;

&lt;p&gt;传共享调用本质上是传递对象的指针的拷贝，其指针也是变量的值。所以传共享调用也可以说是传值调用。&lt;/p&gt;

&lt;p&gt;所以《JavaScript 高级程序设计》说 &lt;strong&gt;JavaScript 参数传递都是按值传参&lt;/strong&gt; 也是有道理的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Evaluation_strategy&#34;&gt;Evaluation strategy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5&#34;&gt;求值策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy&#34;&gt;ECMA-262-3 in detail. Chapter 8. Evaluation strategy.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language&#34;&gt;Is JavaScript a pass-by-reference or pass-by-value language?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/simongong/js-stackoverflow-highest-votes/blob/master/questions21-30/parameter-passed-by-value-or-reference.md&#34;&gt;parameter passed by value or reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://bosn.me/js/js-call-by-sharing/&#34;&gt;JS是按值传递还是按引用传递?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Symmetric Difference</title>
      <link>http://nodejh.com/post/Symmetric-Difference/</link>
      <pubDate>Sat, 29 Oct 2016 00:43:22 +0800</pubDate>
      
      <guid>http://nodejh.com/post/Symmetric-Difference/</guid>
      <description>&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组.&lt;/p&gt;

&lt;p&gt;给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 &amp;ldquo;对等差分&amp;rdquo; 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&#34;&gt;Array.prototype.reduce&lt;/a&gt; 对数组进行遍历。传入的两个参数分别是 prev (对等差分后数组)，curr（当前数组）&lt;/li&gt;
&lt;li&gt;将 sym() 的第一个参数作为初始对等差分数组，即第一个 prev&lt;/li&gt;
&lt;li&gt;对 prev 数组和 curr 数组去重，防止重复元素影响对等差分的结果&lt;/li&gt;
&lt;li&gt;遍历 curr 数组，以此判断 curr 数组中每个元素是否在 prev 中出现。如果出现，则从 prev 中删除该元素；如果没有出现，则将其加入到 prev 中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 对等差分
function sym(args) {
  var arr = Array.prototype.slice.call(arguments);
  return arr.reduce(function(prev, curr) {
      prev = unique(prev);
      curr = unique(curr);
      for (var i=0; i&amp;lt;curr.length; i++) {
          if (prev.indexOf(curr[i]) === -1) {
             prev.push(curr[i]);
          } else {
              prev.splice(prev.indexOf(curr[i]), 1);
          }
          console.log(&#39;new: &#39;, prev);
      }
      return prev.sort();
  });
}


// 数组去重
function unique(arr) {
    var res = [];
    for (var i=0; i&amp;lt;arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
            res.push(arr[i]);
        }
    }
    return res;
}


// sym([1, 2, 3], [5, 2, 1, 4]);
sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果：&lt;a href=&#34;https://www.freecodecamp.cn/challenges/symmetric-difference&#34;&gt;Symmetric Difference&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Github Issue: &lt;a href=&#34;https://github.com/nodejh/nodejh.github.io/issues/1&#34;&gt;https://github.com/nodejh/nodejh.github.io/issues/1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get the Max Number in Array</title>
      <link>http://nodejh.com/post/Get-the-Max-Number-in-Array/</link>
      <pubDate>Mon, 24 Oct 2016 19:20:03 +0800</pubDate>
      
      <guid>http://nodejh.com/post/Get-the-Max-Number-in-Array/</guid>
      <description>

&lt;p&gt;本文介绍 JavaScript 的几种从数组中找出最大值的方法。&lt;/p&gt;

&lt;h4 id=&#34;使用递归函数&#34;&gt;使用递归函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var arr = [9,8,55,66,49,68,109,55,33,6,2,1];
var max = arr[0];
function findMax( i ){
  if( i == arr.length ) return max;
  if( max &amp;lt; arr[i] ) max = arr[i];
  findMax(i+1);
}

findMax(1);
console.log(max);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用-for-循环遍历&#34;&gt;使用 for 循环遍历&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var arr = [9,8,55,66,49,68,109,55,33,6,2,1];  
var max = arr[0];
for(var i = 1; i &amp;lt; arr.length; i++){
  if( max &amp;lt; arr[i] ){
    max = arr[i];
  }
}

console.log(max);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用apply将数组传入max方法中直接返回&#34;&gt;使用apply将数组传入max方法中直接返回&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Math.max.apply(null,[9,8,55,66,49,68,109,55,33,6,2,1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，还有很多数组排序方式，都可以在排序后，根据新数组索引值获取 最大/最小 值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a=[1,2,3,5];
console.log(Math.max.apply(null, a));//最大值
console.log(Math.min.apply(null, a));//最小值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多维数组可以这么修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a=[1,2,3,[5,6],[1,4,8]];
var ta=a.join(&amp;quot;,&amp;quot;).split(&amp;quot;,&amp;quot;);//转化为一维数组
console.log(Math.max.apply(null,ta));//最大值
console.log(Math.min.apply(null,ta));//最小值
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Github Issue: &lt;a href=&#34;https://github.com/nodejh/nodejh.github.io/issues/9&#34;&gt;https://github.com/nodejh/nodejh.github.io/issues/9&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check Parameters in Express Router</title>
      <link>http://nodejh.com/post/Check-Parameters-in-Express-Router/</link>
      <pubDate>Sat, 15 Oct 2016 06:46:05 +0800</pubDate>
      
      <guid>http://nodejh.com/post/Check-Parameters-in-Express-Router/</guid>
      <description>

&lt;p&gt;本文以 Express 框架为基础，讲诉如何通过一个中间件来检测 Express 路由中传输的参数是否合法。&lt;/p&gt;

&lt;p&gt;几乎对于任何应用，前后端都需要进行传输数据。不管是通过 HTTP 请求的 POST 方法还是 GET 方法，数据校验都是必要的操作。&lt;/p&gt;

&lt;p&gt;对于大部分 API 来说，可能只需要判断传入的参数是否为 undefined 或 null，所以这个时候，为了减少重复代码，我们可以写一个简单的中间件来处理路由中的参数。&lt;/p&gt;

&lt;p&gt;这个中间件的需求如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检测路由中的一般参数是否为 undefined、null、[]、&amp;rdquo;&lt;/li&gt;
&lt;li&gt;中间件同时还需要能对特殊参数做处理，如一个参数值在 1-100 之间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终写出来的处理参数的模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 检测路由中的参数
 * @method checkParameters
 * @param  {object}        req     http请求
 * @param  {object}        res     http响应
 * @param  {Function}      next    
 * @param  {[type]}        special 特殊参数，
 *                                 格式： [{eval: &#39;req.query.id&amp;gt;0&#39;, key:&#39;id&#39;, type: &#39;query&#39;}]
 *                                 key 属性的值必须和eval中对应，且type只能是 query/params/body
 * @return {object}        若参数错误，直接返回json到前端；正确，则next()
 */
function checkParameters(req, res, next, special) {
  // console.log(&#39;params: &#39;, req.params);
  // console.log(&#39;body: &#39;, req.body);
  // console.log(&#39;query: &#39;, req.query);
  console.log(&#39;specialParams: &#39;, typeof special);
  // 判断是否传入第四个参数
  if (Array.isArray(special)) {
    // 判断特殊参数
    for (let i = 0; i &amp;lt; special.length; i++) {
      // console.log(&#39;special[i]: &#39;, special[i]);
      // console.log(&#39;special[i] eval: &#39;, special[i].hasOwnProperty(&#39;eval&#39;));
      // console.log(&#39;special[i] key: &#39;, special[i].hasOwnProperty(&#39;key&#39;));
      // console.log(&#39;special[i] type: &#39;, special[i].hasOwnProperty(&#39;type&#39;));

      // 判断是否具有 eval, key, type 三个参数
      if (! (special[i].hasOwnProperty(&#39;eval&#39;)
        &amp;amp;&amp;amp; special[i].hasOwnProperty(&#39;key&#39;)
        &amp;amp;&amp;amp; special[i].hasOwnProperty(&#39;type&#39;))) {
        return res.json({
          code: 90001,
          msg: &#39;检测参数属否正确时，传入的特殊参数格式不完全&#39;,
          detail: special
        });
      }
      // 判断 eval, key, type 三个参数是否为 undefined
      if ( !(typeof special[i][&#39;eval&#39;] !== undefined
      &amp;amp;&amp;amp; typeof special[i][&#39;key&#39;] !== undefined
      &amp;amp;&amp;amp; typeof special[i][&#39;type&#39;] !== undefined)) {
        return res.json({
          code: 90002,
          msg: &#39;检测参数属否正确时，传入的特殊参数为 undefined&#39;,
          detail: special
        });
      }
      const evalString = special[i][&#39;eval&#39;];
      const type = special[i][&#39;type&#39;];
      const key = special[i][&#39;key&#39;];
      // 判断 key 和 eval 是否匹配
      console.log(&#39;length: &#39;, evalString
      .split(&#39;req.&#39; + type + &#39;.&#39; + key)
      .length);
      const length = evalString.split(&#39;req.&#39; + type + &#39;.&#39; + key).length;
      if (length &amp;lt; 1) {
        return res.json({
          code: 90003,
          msg: &#39;检测参数属否正确时，传入的特殊参数为格式不正确&#39;,
          detail: special
        });
      }
      // 执行 eval
      if (!eval(evalString)) {
        return res.json({
          code: 90004,
          msg: &#39;检测参数属否正确时，参数不匹配传入的条件 &#39; + evalString,
          detail: special,
          parameters: req[type]
        });
      }
      // 从普通参数中删除特殊参数
      // console.log(&#39;delete: &#39;, req[type][key]);
      delete req[type][key];
    }
  }

  const params = req.params;
  // 去掉 req.params 中 {&#39;0&#39;: &#39;&#39;, ...} 这一项
  delete params[&#39;0&#39;];
  // console.log(&#39;params: &#39;, params);
  const body = req.body;
  const query = req.query;
  const common = Object.assign(params, body, query);
  console.log(&#39;common: &#39;, common);
  // 检测参数属否为undefined
  for (let i in common) {
    if (typeof common[i] === &#39;undefined&#39;) {
      return res.json({
        code: 90005,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为undefined&#39;,
        detail: common
      });
    }
    // 检测参数属否为null
    if (common[i] === null) {
      return res.json({
        code: 90006,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为null&#39;,
        detail: common
      });
    }
    // 检测参数是否为空字符串 &#39;&#39;
    if (common[i] === &#39;&#39;) {
      return res.json({
        code: 90007,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为空字符串&#39;,
        detail: common
      });
    }
    // 检测参数是否为空数组 []
    if (common[i] === &#39;&#39;) {
      return res.json({
        code: 90008,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为空数组&#39;,
        detail: common
      });
    }
  }

  return next();
}

module.exports = checkParameters;

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数详解&#34;&gt;函数详解&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. 特殊参数的处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个模块，首先对特殊参数做处理。&lt;code&gt;special&lt;/code&gt; 这个参数是一个数组，格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
  eval: &#39;parseInt(req.query.id) &amp;gt; 1 &amp;amp;&amp;amp; parseInt(req.query.id) &amp;lt; 10&#39;,
  key: &#39;id&#39;,
  type: &#39;query&#39;
}, {
  eval: &#39;parseInt(req.query.age) === 11&#39;,
  key: &#39;age&#39;,
  type: &#39;query&#39;
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key 属性的值必须和eval中对应，且type只能是 query/params/body。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先判断函数是否传入第四个参数，并且第四个参数是否为数组，如果这两个条件成立，说明有特殊参数需要处理。&lt;/li&gt;
&lt;li&gt;然后判断是否具有 eval, key, type 三个参数。eval 参数是一个参数条件表达式，如 &amp;lsquo;id&amp;gt;0&amp;rsquo;，最终通过 &lt;code&gt;eval()&lt;/code&gt; 函数来执行这个表达式。&lt;code&gt;key&lt;/code&gt; 表示参数属性名，type 表示是通过何种方式传递的参数，如 query/params/body。&lt;/li&gt;
&lt;li&gt;接下来判断  eval, key, type 三个参数自身是否为 undefined 或 null&lt;/li&gt;
&lt;li&gt;再然后判断 判断 key 和 eval 是否匹配。key 和 eval 的匹配，主要是为了后面从一般参数中删除特殊参数&lt;/li&gt;
&lt;li&gt;再执行 eval 表达式，判断表达式是否成立，即特殊参数值是否合法&lt;/li&gt;
&lt;li&gt;如果以上都为真，说明特殊参数合法，最后则使用 delete 从参数中删除特殊参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 普通参数处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;处理完毕特殊参数后，就需要处理普通参数。普通参数只需要满足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不为 &lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不为 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不为空字符串 &lt;code&gt;&#39;&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不为空数组 &lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;普通参数，即 &lt;code&gt;req.body&lt;/code&gt; &lt;code&gt;req.params&lt;/code&gt; &lt;code&gt;req.query&lt;/code&gt; 中的所有非特殊参数。&lt;/p&gt;

&lt;p&gt;除了在判断特殊参数的时候，需要 delete 特殊参数，还需要 &lt;code&gt;delete req.params[&#39;0&#39;]&lt;/code&gt;。因为对于 &lt;code&gt;req.params&lt;/code&gt;，当 URL 没有 &lt;code&gt;path&lt;/code&gt; 部分的时候，&lt;code&gt;req.params[&#39;0&#39;]&lt;/code&gt; 为 &lt;code&gt;&#39;&#39;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;处理完毕之后，若所有参数都合法，则返回 &lt;code&gt;next()&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;模块使用&#34;&gt;模块使用&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. 创建没有挂载路径的中间件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先在 Express 项目入口文件，创建一个参数处理中间件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// app.js
const checkParameters = require(&#39;./checkParameters&#39;);
// ...
app.use(function(req, res, next) {
  checkParameters(req, res, next);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的 &lt;code&gt;app.use()&lt;/code&gt; 需要放在创建具体路由中间件如&lt;code&gt;app.use(&#39;/&#39;, index)&lt;/code&gt; 之前。&lt;/p&gt;

&lt;p&gt;当 Express 接收到 HTTP 请求后，首先该中间件会检测参数是否合法（只判断是否为 null 或 undefine 或 &amp;ldquo; 或 []）。如果不合法，则直接返回；如果合法，则程序继续执行，由匹配该请求路径的路由继续完成该请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 创建挂载路径的中间件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果需要对某个路由的特殊参数做处理，则需要创建一个挂载路径的中间件。&lt;/p&gt;

&lt;p&gt;比如为们要判断 &lt;code&gt;/index&lt;/code&gt; 路由的 GET 请求中的 &lt;code&gt;id&lt;/code&gt; 参数，其中 &lt;code&gt;id&lt;/code&gt; 的取值范围是 1-100，URL 形式如 &lt;code&gt;http://localhost:3000/index?id=10&lt;/code&gt;，则可以这样使用该模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
const checkParameters = require(&#39;./checkParameters&#39;);

// 挂载路径的中间件
router.get(&#39;/index&#39;, function(req, res, next) {
  const special = {
    eval: &#39;parseInt(req.query.id) &amp;gt;= 1 &amp;amp;&amp;amp; parseInt(req.query.id) &amp;lt;= 100&#39;,
    key: &#39;id&#39;,
    type: &#39;query&#39;
  };
  checkParameters(req, res, next, special);
});
// 正常逻辑处理
router.get(&#39;/index&#39;, function(req, res, next) {
  // 正常逻辑
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 Express 接收到一个 HTTP 请求的时候，首先还是没有挂载路径的中间件先处理请求，检测参数；然后该挂载路径的中间件再检测参数；最后才执行正常处理逻辑。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Github Issue: &lt;a href=&#34;https://github.com/nodejh/nodejh.github.io/issues/5&#34;&gt;https://github.com/nodejh/nodejh.github.io/issues/5&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AJAX: XHR, jQuery and Fetch API</title>
      <link>http://nodejh.com/post/ajax-xhr-jquery-and-fetch-api/</link>
      <pubDate>Mon, 26 Sep 2016 19:58:03 +0800</pubDate>
      
      <guid>http://nodejh.com/post/ajax-xhr-jquery-and-fetch-api/</guid>
      <description>&lt;p&gt;本文详细讲述如何使用原生 JS、jQuery 和 Fetch 来实现 AJAX。&lt;/p&gt;

&lt;p&gt;AJAX 即 Asynchronous JavaScript and XML，异步的 JavaScript 和 XML。使用 AJAX 可以无刷新地向服务端发送请求接收服务端响应，并更新页面。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-原生-js-实现-ajax&#34;&gt;一、原生 JS 实现 AJAX&lt;/h2&gt;

&lt;p&gt;JS 实现 AJAX 主要基于浏览器提供的 XMLHttpRequest（XHR）类，所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。&lt;/p&gt;

&lt;h4 id=&#34;1-获取xmlhttprequest对象&#34;&gt;1. 获取XMLHttpRequest对象&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 获取XMLHttpRequest对象
var xhr = new XMLHttpRequest();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要兼容老版本的 IE (IE5, IE6) 浏览器，则可以使用 ActiveX 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-发送一个-http-请求&#34;&gt;2. 发送一个 HTTP 请求&lt;/h4&gt;

&lt;p&gt;接下来，我们需要打开一个URL，然后发送这个请求。分别要用到 XMLHttpRequest 的 open() 方法和 send() 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET
var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
if (xhr) {
  xhr.open(&#39;GET&#39;, &#39;/api?username=admin&amp;amp;password=root&#39;, true);
  xhr.send(null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// POST
var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
if (xhr) {
  xhr.open(&#39;POST&#39;, &#39;/api&#39;, true);
  // 设置 Content-Type 为 application/x-www-form-urlencoded
  // 以表单的形式传递数据
  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);
  xhr.send(&#39;username=admin&amp;amp;password=root&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 方法有三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open()&lt;/code&gt; 的第一个参数是 HTTP 请求方式 – GET，POST，HEAD 或任何服务器所支持的您想调用的方式。按照HTTP规范，该参数要大写；否则，某些浏览器(如Firefox)可能无法处理请求。有关HTTP请求方法的详细信息可参考 &lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&#34;&gt;https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第二个参数是请求页面的 URL。由于同源策略（Same origin policy）该页面不能为第三方域名的页面。同时一定要保证在所有的页面中都使用准确的域名，否则调用 &lt;code&gt;open()&lt;/code&gt; 会得到 &lt;code&gt;permission denied&lt;/code&gt; 的错误提示。&lt;/li&gt;
&lt;li&gt;第三个参数设置请求是否为异步模式。如果是 &lt;code&gt;TRUE&lt;/code&gt;，JavaScript 函数将继续执行，而不等待服务器响应。这就是 AJAX 中的 A。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果第一个参数是 &lt;code&gt;GET&lt;/code&gt;，则可以直接将参数放在 url 后面，如：&lt;code&gt;http://nodejh.com/api?name=admint&amp;amp;password=root&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果第一个参数是 &lt;code&gt;POST&lt;/code&gt;，则需要将参数写在 send() 方法里面。send() 方法的参数可以是任何想送给服务器的数据。这时数据要以字符串的形式送给服务器，如：&lt;code&gt;name=admint&amp;amp;password=root&lt;/code&gt;。或者也可以传递 JSON 格式的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 设置 Content-Type 为 application/json
xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);
// 传递 JSON 字符串
xhr.send(JSON.stringify({ username:&#39;admin&#39;, password:&#39;root&#39; }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不设置请求头，原生 AJAX 会默认使用 Content-Type 是 &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; 的方式发送数据。&lt;/p&gt;

&lt;p&gt;关于 Content-Type 更详细的内容，将在以后的文章中解释说明。&lt;/p&gt;

&lt;h4 id=&#34;3-处理服务器的响应&#34;&gt;3. 处理服务器的响应&lt;/h4&gt;

&lt;p&gt;当发送请求时，我们需要指定如何处理服务器的响应，我们需要用到 onreadystatechange 属性来检测服务器的响应状态。使用 onreadystatechange 有两种方式，一是直接 onreadystatechange 属性指定一个可调用的函数名，二是使用一个匿名函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 方法一 指定可调用的函数
xhr.onreadystatechange = onReadyStateChange;
function onReadyStateChange() {
  // do something
}

// 方法二 使用匿名函数
xhr.onreadystatechange = function(){
    // do the thing
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们需要在内部利用 readyState 属性来获取当前的状态，当 readyState 的值为 4，就意味着一个完整的服务器响应已经收到了，接下来就可以处理该响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// readyState的取值如下
// 0 (未初始化)
// 1 (正在装载)
// 2 (装载完毕)
// 3 (交互中)
// 4 (完成)
if (xhr.readyState === 4) {
    // everything is good, the response is received
} else {
    // still not ready
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// POST
var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
if (xhr) {
  xhr.onreadystatechange = onReadyStateChange;
  xhr.open(&#39;POST&#39;, &#39;/api&#39;, true);
  // 设置 Content-Type 为 application/x-www-form-urlencoded
  // 以表单的形式传递数据
  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);
  xhr.send(&#39;username=admin&amp;amp;password=root&#39;);
}


// onreadystatechange 方法
function onReadyStateChange() {
  // 该函数会被调用四次
  console.log(xhr.readyState);
  if (xhr.readyState === 4) {
    // everything is good, the response is received
    if (xhr.status === 200) {
      console.log(xhr.responseText);
    } else {
      console.log(&#39;There was a problem with the request.&#39;);
    }
  } else {
    // still not ready
    console.log(&#39;still not ready...&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然我们可以用onload来代替onreadystatechange等于4的情况，因为onload只在状态为4的时候才被调用，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xhr.onload = function () {    // 调用onload
    if (xhr.status === 200) {    // status为200表示请求成功
        console.log(&#39;执行成功&#39;);
    } else {
        console.log(&#39;执行出错&#39;);
    }   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而需要注意的是，IE对 onload 属性的支持并不友好。除了 onload 还有以下几个属性也可以用来监测响应状态：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onloadstart&lt;/li&gt;
&lt;li&gt;onprogress&lt;/li&gt;
&lt;li&gt;onabort&lt;/li&gt;
&lt;li&gt;ontimeout&lt;/li&gt;
&lt;li&gt;onerror&lt;/li&gt;
&lt;li&gt;onloadend&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-jquery-实现-ajax&#34;&gt;二、 jQuery 实现 AJAX&lt;/h2&gt;

&lt;p&gt;jQuery 作为一个使用人数最多的库，其 AJAX 很好的封装了原生 AJAX 的代码，在兼容性和易用性方面都做了很大的提高，让 AJAX 的调用变得非常简单。下面便是一段简单的 jQuery 的 AJAX 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
  method: &#39;POST&#39;,
  url: &#39;/api&#39;,
  data: { username: &#39;admin&#39;, password: &#39;root&#39; }
})
  .done(function(msg) {
    alert( &#39;Data Saved: &#39; + msg );
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比原生 AJAX 的实现，使用 jQuery 就异常简单了。当然我们平时用的最多的，是下面两种更简单的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET
$.get(&#39;/api&#39;, function(res) {
  // do something
});

// POST
var data = {
  username: &#39;admin&#39;,
  password: &#39;root&#39;
};
$.post(&#39;/api&#39;, data, function(res) {
  // do something
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-fetch-api&#34;&gt;三、Fetch API&lt;/h2&gt;

&lt;p&gt;使用 jQuery 虽然可以大大简化 XMLHttpRequest 的使用，但 XMLHttpRequest 本质上但并不是一个设计优良的 API：
+ 不符合关注分离（Separation of Concerns）的原则
+ 配置和调用方式非常混乱
+ 使用事件机制来跟踪状态变化
+ 基于事件的异步模型没有现代的 Promise，generator/yield，async/await 友好&lt;/p&gt;

&lt;p&gt;Fetch API 旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 &lt;code&gt;fetch()&lt;/code&gt; 这个实用的方法来获取网络资源。&lt;/p&gt;

&lt;p&gt;Fetch 的浏览器兼容图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nodejh.com/images/ajax-js-jquery-and-fetch-api-0.png&#34; alt=&#34;ajax-js-jquery-and-fetch-api-0.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于 IE8 是 ES3，需要引入 ES5 的 polyfill: &lt;a href=&#34;https://github.com/es-shims/es5-shim&#34;&gt;es5-shim, es5-sham&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入 Promise 的 polyfill: &lt;a href=&#34;https://github.com/stefanpenner/es6-promise&#34;&gt;es6-promise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入 fetch 探测库：&lt;a href=&#34;https://github.com/camsong/fetch-detector&#34;&gt;fetch-detector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入 fetch 的 polyfill: &lt;a href=&#34;https://github.com/camsong/fetch-ie8&#34;&gt;fetch-ie8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可选：如果你还使用了 jsonp，引入 &lt;a href=&#34;https://github.com/camsong/fetch-jsonp&#34;&gt;fetch-jsonp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可选：开启 Babel 的 runtime 模式，现在就使用 async/await&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-一个使用-fetch-的例子&#34;&gt;1. 一个使用 Fetch 的例子&lt;/h4&gt;

&lt;p&gt;先看一个简单的 Fetch API 的例子 🌰 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetch(&#39;/api&#39;).then(function(response) {
  return response.json();
}).then(function(data) {
  console.log(data);
}).catch(function(error) {
  console.log(&#39;Oops, error: &#39;, error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 ES6 的箭头函数后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetch(&#39;/api&#39;).then(response =&amp;gt; response.json())
  .then(data =&amp;gt; console.log(data))
  .catch(error =&amp;gt; console.log(&#39;Oops, error: &#39;, error))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出使用Fetch后我们的代码更加简洁和语义化，链式调用的方式也使其更加流畅和清晰。但这种基于 Promise 的写法还是有 Callback 的影子，我们还可以用 &lt;code&gt;async/await&lt;/code&gt; 来做最终优化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async function() {
  try {
    let response = await fetch(url);
    let data = response.json();
    console.log(data);
  } catch (error) {
    console.log(&#39;Oops, error: &#39;, error);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;await&lt;/code&gt; 后，写代码就更跟同步代码一样。&lt;code&gt;await&lt;/code&gt; 后面可以跟 Promise 对象，表示等待 Promise &lt;code&gt;resolve()&lt;/code&gt; 才会继续向下执行，如果 Promise 被 &lt;code&gt;reject()&lt;/code&gt; 或抛出异常则会被外面的 &lt;code&gt;try...catch&lt;/code&gt; 捕获。&lt;/p&gt;

&lt;p&gt;Promise，generator/yield，await/async 都是现在和未来 JS 解决异步的标准做法，可以完美搭配使用。这也是使用标准 Promise 一大好处。&lt;/p&gt;

&lt;h4 id=&#34;2-使用-fetch-的注意事项&#34;&gt;2. 使用 Fetch 的注意事项&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Fetch 请求默认是不带 cookie，需要设置 &lt;code&gt;fetch(url, {credentials: &#39;include&#39;})&lt;/code&gt;`&lt;/li&gt;
&lt;li&gt;服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来将上面基于 XMLHttpRequest 的 AJAX 用 Fetch 改写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var options = {
    method: &#39;POST&#39;,
    headers: {
      &#39;Accept&#39;: &#39;application/json&#39;,
      &#39;Content-Type&#39;: &#39;application/json&#39;
    },
    body: JSON.stringify({ username: &#39;admin&#39;, password: &#39;root&#39; }),
    credentials: &#39;include&#39;
  };

fetch(&#39;/api&#39;, options).then(response =&amp;gt; response.json())
  .then(data =&amp;gt; console.log(data))
  .catch(error =&amp;gt; console.log(&#39;Oops, error: &#39;, error))
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Github Issue: &lt;a href=&#34;https://github.com/nodejh/nodejh.github.io/issues/15&#34;&gt;https://github.com/nodejh/nodejh.github.io/issues/15&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Get Chinese Phonetic Syllable With JS</title>
      <link>http://nodejh.com/post/Get-Chinese-Phonetic-Syllable-With-JS/</link>
      <pubDate>Wed, 13 Apr 2016 10:35:40 +0800</pubDate>
      
      <guid>http://nodejh.com/post/Get-Chinese-Phonetic-Syllable-With-JS/</guid>
      <description>&lt;h3 id=&#34;最终函数&#34;&gt;最终函数&lt;/h3&gt;

&lt;p&gt;最近在抓取 Rice 大学的博士生姓名，并从中获取到中国人的姓名。由于博士有中国人和外国人，而中国人的姓名是由拼音组成，所以最终需求是这样的，判断一个字符串是否是由拼音音节组成。于是写了下面这个函数：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 判断输入的一个字符串是不是拼音
 * @param string 需要测试的字符串
 * @returns {*}
 */
function is_pinyin(string) {

  var list = [&#39;a&#39;, &#39;ai&#39;, &#39;an&#39;, &#39;ang&#39;, &#39;ao&#39;, &#39;ba&#39;, &#39;bai&#39;, &#39;ban&#39;, &#39;bang&#39;, &#39;bao&#39;, &#39;bei&#39;, &#39;ben&#39;,
    &#39;beng&#39;, &#39;bi&#39;, &#39;bian&#39;, &#39;biao&#39;, &#39;bie&#39;, &#39;bin&#39;, &#39;bing&#39;, &#39;bo&#39;, &#39;bu&#39;, &#39;ca&#39;, &#39;cai&#39;, &#39;can&#39;, &#39;cang&#39;,
    &#39;cao&#39;, &#39;ce&#39;, &#39;cen&#39;, &#39;ceng&#39;, &#39;cha&#39;, &#39;chai&#39;, &#39;chan&#39;, &#39;chang&#39;, &#39;chao&#39;, &#39;che&#39;, &#39;chen&#39;, &#39;cheng&#39;, &#39;chi&#39;,
    &#39;chong&#39;, &#39;chou&#39;, &#39;chu&#39;, &#39;chua&#39;, &#39;chuai&#39;, &#39;chuan&#39;, &#39;chuang&#39;, &#39;chui&#39;, &#39;chun&#39;, &#39;chuo&#39;, &#39;ci&#39;, &#39;cong&#39;,
    &#39;cou&#39;, &#39;cu&#39;, &#39;cuan&#39;, &#39;cui&#39;, &#39;cun&#39;, &#39;cuo&#39;, &#39;da&#39;, &#39;dai&#39;, &#39;dan&#39;, &#39;dang&#39;, &#39;dao&#39;, &#39;de&#39;, &#39;dei&#39;, &#39;den&#39;,
    &#39;deng&#39;, &#39;di&#39;, &#39;dia&#39;, &#39;dian&#39;, &#39;diao&#39;, &#39;die&#39;, &#39;ding&#39;, &#39;diu&#39;, &#39;dong&#39;, &#39;dou&#39;, &#39;du&#39;, &#39;duan&#39;, &#39;dui&#39;, &#39;dun&#39;,
    &#39;duo&#39;, &#39;e&#39;, &#39;en&#39;, &#39;eng&#39;, &#39;er&#39;, &#39;fa&#39;, &#39;fan&#39;, &#39;fang&#39;, &#39;fei&#39;, &#39;fen&#39;, &#39;feng&#39;, &#39;fiao&#39;, &#39;fo&#39;, &#39;fou&#39;, &#39;fu&#39;,
    &#39;ga&#39;, &#39;gai&#39;, &#39;gan&#39;, &#39;gang&#39;, &#39;gao&#39;, &#39;ge&#39;, &#39;gei&#39;, &#39;gen&#39;, &#39;geng&#39;, &#39;gong&#39;, &#39;gou&#39;, &#39;gu&#39;, &#39;gua&#39;, &#39;guai&#39;, &#39;guan&#39;,
    &#39;guang&#39;, &#39;gui&#39;, &#39;gun&#39;, &#39;guo&#39;, &#39;ha&#39;, &#39;hai&#39;, &#39;han&#39;, &#39;hang&#39;, &#39;hao&#39;, &#39;he&#39;, &#39;hei&#39;, &#39;hen&#39;, &#39;heng&#39;, &#39;hong&#39;, &#39;hou&#39;,
    &#39;hu&#39;, &#39;hua&#39;, &#39;huai&#39;, &#39;huan&#39;, &#39;huang&#39;, &#39;hui&#39;, &#39;hun&#39;, &#39;huo&#39;, &#39;ji&#39;, &#39;jia&#39;, &#39;jian&#39;, &#39;jiang&#39;, &#39;jiao&#39;, &#39;jie&#39;,
    &#39;jin&#39;, &#39;jing&#39;, &#39;jiong&#39;, &#39;jiu&#39;, &#39;ju&#39;, &#39;juan&#39;, &#39;jue&#39;, &#39;ka&#39;, &#39;kai&#39;, &#39;kan&#39;, &#39;kang&#39;, &#39;kao&#39;, &#39;ke&#39;, &#39;ken&#39;,
    &#39;keng&#39;, &#39;kong&#39;, &#39;kou&#39;, &#39;ku&#39;, &#39;kua&#39;, &#39;kuai&#39;, &#39;kuan&#39;, &#39;kuang&#39;, &#39;kui&#39;, &#39;kun&#39;, &#39;kuo&#39;, &#39;la&#39;, &#39;lai&#39;, &#39;lan&#39;,
    &#39;lang&#39;, &#39;lao&#39;, &#39;le&#39;, &#39;lei&#39;, &#39;leng&#39;, &#39;li&#39;, &#39;lia&#39;, &#39;lian&#39;, &#39;liang&#39;, &#39;liao&#39;, &#39;lie&#39;, &#39;lin&#39;, &#39;ling&#39;, &#39;liu&#39;,
    &#39;lo&#39;, &#39;long&#39;, &#39;lou&#39;, &#39;lu&#39;, &#39;luan&#39;, &#39;lun&#39;, &#39;luo&#39;, &#39;lv&#39;, &#39;lve&#39;, &#39;ma&#39;, &#39;mai&#39;, &#39;man&#39;, &#39;mang&#39;, &#39;mao&#39;, &#39;me&#39;,
    &#39;mei&#39;, &#39;men&#39;, &#39;meng&#39;, &#39;mi&#39;, &#39;mian&#39;, &#39;miao&#39;, &#39;mie&#39;, &#39;min&#39;, &#39;ming&#39;, &#39;miu&#39;, &#39;mo&#39;, &#39;mou&#39;, &#39;mu&#39;, &#39;na&#39;, &#39;nai&#39;,
    &#39;nan&#39;, &#39;nang&#39;, &#39;nao&#39;, &#39;ne&#39;, &#39;nei&#39;, &#39;nen&#39;, &#39;neng&#39;, &#39;ni&#39;, &#39;nian&#39;, &#39;niang&#39;, &#39;niao&#39;, &#39;nie&#39;, &#39;nin&#39;, &#39;ning&#39;,
    &#39;niu&#39;, &#39;nong&#39;, &#39;nou&#39;, &#39;nu&#39;, &#39;nuan&#39;, &#39;nun&#39;, &#39;nuo&#39;, &#39;nv&#39;, &#39;nve&#39;, &#39;o&#39;, &#39;ou&#39;, &#39;pa&#39;, &#39;pai&#39;, &#39;pan&#39;, &#39;pang&#39;, &#39;pao&#39;,
    &#39;pei&#39;, &#39;pen&#39;, &#39;peng&#39;, &#39;pi&#39;, &#39;pian&#39;, &#39;piao&#39;, &#39;pie&#39;, &#39;pin&#39;, &#39;ping&#39;, &#39;po&#39;, &#39;pou&#39;, &#39;pu&#39;, &#39;qi&#39;, &#39;qia&#39;, &#39;qian&#39;,
    &#39;qiang&#39;, &#39;qiao&#39;, &#39;qie&#39;, &#39;qin&#39;, &#39;qing&#39;, &#39;qiong&#39;, &#39;qiu&#39;, &#39;qu&#39;, &#39;quan&#39;, &#39;que&#39;, &#39;qun&#39;, &#39;ran&#39;, &#39;rang&#39;, &#39;rao&#39;,
    &#39;re&#39;, &#39;ren&#39;, &#39;reng&#39;, &#39;ri&#39;, &#39;rong&#39;, &#39;rou&#39;, &#39;ru&#39;, &#39;rua&#39;, &#39;ruan&#39;, &#39;rui&#39;, &#39;run&#39;, &#39;ruo&#39;, &#39;sa&#39;, &#39;sai&#39;, &#39;san&#39;,
    &#39;sang&#39;, &#39;sao&#39;, &#39;se&#39;, &#39;sen&#39;, &#39;seng&#39;, &#39;sha&#39;, &#39;shai&#39;, &#39;shan&#39;, &#39;shang&#39;, &#39;shao&#39;, &#39;she&#39;, &#39;shei&#39;, &#39;shen&#39;, &#39;sheng&#39;,
    &#39;shi&#39;, &#39;shou&#39;, &#39;shu&#39;, &#39;shua&#39;, &#39;shuai&#39;, &#39;shuan&#39;, &#39;shuang&#39;, &#39;shui&#39;, &#39;shun&#39;, &#39;shuo&#39;, &#39;si&#39;, &#39;song&#39;, &#39;sou&#39;,
    &#39;su&#39;, &#39;suan&#39;, &#39;sui&#39;, &#39;sun&#39;, &#39;suo&#39;, &#39;ta&#39;, &#39;tai&#39;, &#39;tan&#39;, &#39;tang&#39;, &#39;tao&#39;, &#39;te&#39;, &#39;tei&#39;, &#39;teng&#39;, &#39;ti&#39;, &#39;tian&#39;,
    &#39;tiao&#39;, &#39;tie&#39;, &#39;ting&#39;, &#39;tong&#39;, &#39;tou&#39;, &#39;tu&#39;, &#39;tuan&#39;, &#39;tui&#39;, &#39;tun&#39;, &#39;tuo&#39;, &#39;wa&#39;, &#39;wai&#39;, &#39;wan&#39;, &#39;wang&#39;,
    &#39;wei&#39;, &#39;wen&#39;, &#39;weng&#39;, &#39;wo&#39;, &#39;wu&#39;, &#39;xi&#39;, &#39;xia&#39;, &#39;xian&#39;, &#39;xiang&#39;, &#39;xiao&#39;, &#39;xie&#39;, &#39;xin&#39;, &#39;xing&#39;, &#39;xiong&#39;,
    &#39;xiu&#39;, &#39;xu&#39;, &#39;xuan&#39;, &#39;xue&#39;, &#39;xun&#39;, &#39;ya&#39;, &#39;yan&#39;, &#39;yang&#39;, &#39;yao&#39;, &#39;ye&#39;, &#39;yi&#39;, &#39;yin&#39;, &#39;ying&#39;, &#39;yo&#39;, &#39;yong&#39;,
    &#39;you&#39;, &#39;yu&#39;, &#39;yuan&#39;, &#39;yue&#39;, &#39;yun&#39;, &#39;za&#39;, &#39;zai&#39;, &#39;zan&#39;, &#39;zang&#39;, &#39;zao&#39;, &#39;ze&#39;, &#39;zei&#39;, &#39;zen&#39;, &#39;zeng&#39;, &#39;zha&#39;,
    &#39;zhai&#39;, &#39;zhan&#39;, &#39;zhang&#39;, &#39;zhao&#39;, &#39;zhe&#39;, &#39;zhei&#39;, &#39;zhen&#39;, &#39;zheng&#39;, &#39;zhi&#39;, &#39;zhong&#39;, &#39;zhou&#39;, &#39;zhu&#39;, &#39;zhua&#39;,
    &#39;zhuai&#39;, &#39;zhuan&#39;, &#39;zhuang&#39;, &#39;zhui&#39;, &#39;zhun&#39;, &#39;zhuo&#39;, &#39;zi&#39;, &#39;zong&#39;, &#39;zou&#39;, &#39;zu&#39;, &#39;zuan&#39;, &#39;zui&#39;, &#39;zun&#39;, &#39;zuo&#39;];
  var lowerString = string.toLowerCase();
  var length = lowerString.length;
  var index = -1;

  for (var i=0; i&amp;lt;length; i++) {
    var name = lowerString.substring(0, i+1);
    index = list.lastIndexOf(name) &amp;gt; index ? list.lastIndexOf(name) : index;
  }
  
  // 判断当前 lowerString 是不是拼音(lowerString 在 list 中就是;不在就不是)
  if (index &amp;gt;= 0) {
    var item = list[index];
     lowerString = lowerString.substring(item.length);
    if (lowerString.length == 0) {
      return string;
    } else {
       return arguments.callee(lowerString);
    }
  } else {
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h4 id=&#34;1-找到所有拼音音节表&#34;&gt;1. 找到所有拼音音节表&lt;/h4&gt;

&lt;p&gt;首先是找到所有的拼音列表，将其存入数组 &lt;code&gt;ist&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;汉语的拼音音节共 399 个，可以在百度百科找到：&lt;a href=&#34;http://baike.baidu.com/view/1253220.htm&#34;&gt;汉语拼音音节&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-递归判断字符串&#34;&gt;2. 递归判断字符串&lt;/h4&gt;

&lt;p&gt;接下来要循环判断传入的字符串是否是拼音音节。也就是说，我们要判断所传入的字符串是否在 &lt;code&gt;lsit&lt;/code&gt; 数组中，聪明的可能想到了，可以用 &lt;code&gt;indexOf()&lt;/code&gt; 来判断。&lt;/p&gt;

&lt;p&gt;那么问题来了，我们所要判断的字符串是姓名，形如 &lt;code&gt;jianghang&lt;/code&gt;，是由两个甚至更多的拼音音节组成的。所以不能直接 &lt;code&gt;list.indexOf(&#39;jianghang&#39;)&lt;/code&gt;，而是要不断循环截取 &lt;code&gt;jianghang&lt;/code&gt; 这个字符串，判读所截取的字符串是否在 &lt;code&gt;list&lt;/code&gt; 数组中。如第一次循环截取的是 &lt;code&gt;j&lt;/code&gt;，然后判断 &lt;code&gt;j&lt;/code&gt; 是否在 &lt;code&gt;lsit&lt;/code&gt; 里面，如果不在，则继续截取 &lt;code&gt;ji&lt;/code&gt; 再判断；如果是，则又从字符串的第三位开始继续判断，直到判断完整个字符串。其实也就是递归。&lt;/p&gt;

&lt;p&gt;然后可能你又发现了，这么做还是有问题。因为 &lt;code&gt;ji&lt;/code&gt; 是拼音音节，&lt;code&gt;jia&lt;/code&gt;、&lt;code&gt;jian&lt;/code&gt;、&lt;code&gt;jiang&lt;/code&gt; 也都是拼音音节。所以这就涉及到一个最优的问题，我们要找到 &lt;code&gt;jiang&lt;/code&gt; 而不是 &lt;code&gt;ji&lt;/code&gt; 或其它。&lt;/p&gt;

&lt;p&gt;根据 &lt;code&gt;lsit&lt;/code&gt; 的规则，排在后面的音节总是最优的音节。所以我们使用 &lt;code&gt;lastIndexOf()&lt;/code&gt; 对数组从后往前筛选。&lt;/p&gt;

&lt;h4 id=&#34;3-还是递归&#34;&gt;3. 还是递归&lt;/h4&gt;

&lt;p&gt;这里需要注意的是 &lt;code&gt;return arguments.callee(lowerString);&lt;/code&gt; 这一行。&lt;code&gt;arguments&lt;/code&gt; 是一个类数组对象，它包含着传入函数的所有参数。这个对象有一个 &lt;code&gt;callee&lt;/code&gt; 属性，该属性是一个指针，指向拥有 &lt;code&gt;arguments&lt;/code&gt; 对象的函数。&lt;/p&gt;

&lt;p&gt;这里我们使用 &lt;code&gt;return  arguments.callee(lowerString)&lt;/code&gt; 而不是用 &lt;code&gt;return is_pinyin(lowerString)&lt;/code&gt; 的好处就是，当我们改变函数名的时候，我们仍然可以正确使用该函数。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Github Issue: &lt;a href=&#34;https://github.com/nodejh/nodejh.github.io/issues/8&#34;&gt;https://github.com/nodejh/nodejh.github.io/issues/8&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>