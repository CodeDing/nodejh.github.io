<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Postbacks on nodejh</title>
    <link>http://nodejh.com/postback/</link>
    <description>Recent content in Postbacks on nodejh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 29 Oct 2016 00:43:22 +0800</lastBuildDate>
    <atom:link href="http://nodejh.com/postback/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Symmetric Difference</title>
      <link>http://nodejh.com/postback/Symmetric-Difference/</link>
      <pubDate>Sat, 29 Oct 2016 00:43:22 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Symmetric-Difference/</guid>
      <description>&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组.&lt;/p&gt;

&lt;p&gt;给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 &amp;ldquo;对等差分&amp;rdquo; 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&#34;&gt;Array.prototype.reduce&lt;/a&gt; 对数组进行遍历。传入的两个参数分别是 prev (对等差分后数组)，curr（当前数组）&lt;/li&gt;
&lt;li&gt;将 sym() 的第一个参数作为初始对等差分数组，即第一个 prev&lt;/li&gt;
&lt;li&gt;对 prev 数组和 curr 数组去重，防止重复元素影响对等差分的结果&lt;/li&gt;
&lt;li&gt;遍历 curr 数组，以此判断 curr 数组中每个元素是否在 prev 中出现。如果出现，则从 prev 中删除该元素；如果没有出现，则将其加入到 prev 中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 对等差分
function sym(args) {
  var arr = Array.prototype.slice.call(arguments);
  return arr.reduce(function(prev, curr) {
      prev = unique(prev);
      curr = unique(curr);
      for (var i=0; i&amp;lt;curr.length; i++) {
          if (prev.indexOf(curr[i]) === -1) {
             prev.push(curr[i]);
          } else {
              prev.splice(prev.indexOf(curr[i]), 1);
          }
          console.log(&#39;new: &#39;, prev);
      }
      return prev.sort();
  });
}


// 数组去重
function unique(arr) {
    var res = [];
    for (var i=0; i&amp;lt;arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
            res.push(arr[i]);
        }
    }
    return res;
}


// sym([1, 2, 3], [5, 2, 1, 4]);
sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果：&lt;a href=&#34;https://www.freecodecamp.cn/challenges/symmetric-difference&#34;&gt;Symmetric Difference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build MXNet on macOS</title>
      <link>http://nodejh.com/postback/Install-MXNet-on-macOS/</link>
      <pubDate>Thu, 27 Oct 2016 15:37:29 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Install-MXNet-on-macOS/</guid>
      <description>

&lt;p&gt;MXNet 是一个深度学习系统。关于 MXNet 的介绍可以看这篇文章：&lt;a href=&#34;https://github.com/dmlc/mxnet/issues/797&#34;&gt;《MXNet设计和实现简介》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在 macOS 上编译安装 MXNet 的大体步骤都是按照官方文档来进行安装即可。但由于每个人电脑环境不同，所以可能会出现一些依赖库／包的缺失，导致安装失败。&lt;/p&gt;

&lt;h4 id=&#34;安装依赖软件&#34;&gt;安装依赖软件&lt;/h4&gt;

&lt;p&gt;在 macOS 上，首先需要具有以下软件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Homebrew (to install dependencies)&lt;/li&gt;
&lt;li&gt;Git (to pull code from GitHub)&lt;/li&gt;
&lt;li&gt;Homebrew/science (for linear algebraic operations)&lt;/li&gt;
&lt;li&gt;OpenCV (for computer vision operations)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果上述已经安装了，就不需要再安装；如果没有，则按照下面的步骤安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装 Homebrew
$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
# 安装 Git 和 OpenCV
$ brew update
$ brew install git
$ brew tap homebrew/science
$ brew info opencv
$ brew install opencv
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;编译-mxnet&#34;&gt;编译 MXNet&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 下载源码
$ git clone --recursive https://github.com/dmlc/mxnet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后还需要安装 &lt;code&gt;openblas&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装 openblas
$ brew install --fresh -vd openblas
...
Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you&#39;ll need to add to your
build variables:

    LDFLAGS:  -L/usr/local/opt/openblas/lib
    CPPFLAGS: -I/usr/local/opt/openblas/include

==&amp;gt; Summary
🍺  /usr/local/Cellar/openblas/0.2.18_2: 20 files, 41.8M, built in 12 minutes 33 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有安装 &lt;code&gt;openblas&lt;/code&gt;，则会有类似 &lt;code&gt;fatal error: &#39;cblas.h&#39; file not found&lt;/code&gt; 的错误，详见 &lt;a href=&#34;https://github.com/dmlc/mxnet/issues/572&#34;&gt;https://github.com/dmlc/mxnet/issues/572&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;接下来修改配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mxnet
$ cp make/osx.mk ./config.mk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 vim 或其他编辑器打开 &lt;code&gt;config.mk&lt;/code&gt;，在 &lt;code&gt;USE_BLAS = apple&lt;/code&gt; 下面加入如下 &lt;code&gt;ADD_LDFLAGS = -I/usr/local/opt/openblas/lib&lt;/code&gt; 和 &lt;code&gt;ADD_CFLAGS =  -I/usr/local/opt/openblas/include&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;USE_BLAS = apple
ADD_LDFLAGS = -I/usr/local/opt/openblas/lib
ADD_CFLAGS =  -I/usr/local/opt/openblas/include
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后再编译即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make -j$(sysctl -n hw.ncpu)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;在-python-中使用-mxnet&#34;&gt;在 Python 中使用 MXNet&lt;/h4&gt;

&lt;p&gt;编译安装完成之后，若要使用 MXNet 的 Python 接口，还需要将 mxnet/python 添加到 Python 的包搜索路径。至少有三种方式可以实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. python 代码手动加载&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os, sys;
cur_path = os.path.abspath(os.path.dirname(__file__));
mxnet_lib_path = os.path.join(cur_path, &#39;mxnet/python&#39;);
sys.path.append(mxnet_lib_path);
import mxnet as mx;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在没有将 &lt;code&gt;mxnet/python&lt;/code&gt; 添加到 PYTHONPATH 之前，依旧可以运行 &lt;code&gt;/example/image-classification&lt;/code&gt; 里面的一些测试案例，就是因为案例里面有一行 &lt;code&gt;import find_mxnet&lt;/code&gt;，而 &lt;code&gt;find_mxnet&lt;/code&gt; 的作用就是手动加载 &lt;code&gt;mxnet/python&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# find_mxnet.py
try:
    import mxnet as mx
except ImportError:
    import os, sys
    curr_path = os.path.abspath(os.path.dirname(__file__))
    sys.path.append(os.path.join(curr_path, &amp;quot;../../python&amp;quot;))
    import mxnet as mx

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 将路径加到环境变量 PYTHONPATH 中&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种方法需要修改 shell 的配置文件。如果使用的 bash，则修改 &lt;code&gt;~/.bashrc&lt;/code&gt;；若使用的是 zsh，则修改 &lt;code&gt;~/.zshrc&lt;/code&gt;；其他类似。&lt;/p&gt;

&lt;p&gt;在 bash 配置文件中加入下面这一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PYTHONPATH=path_to_mxnet_root/python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;path_to_mxnet_root&lt;/code&gt; 是下载的 mxnet 源码目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 全局安装 mxnet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;直接运行 &lt;code&gt;mxnet/python/setup.py&lt;/code&gt;，将 mxnet 添加到全局路径即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python setup.py install --user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上面的命令后，脚本会在 &lt;code&gt;~/.local&lt;/code&gt; 目录下创建一个 &lt;code&gt;lib&lt;/code&gt; 目录，里面有一个 &lt;code&gt;python-2.7/site-packages&lt;/code&gt; 文件夹。&lt;/p&gt;

&lt;p&gt;如果是 &lt;code&gt;sudo python setup.py install&lt;/code&gt;，则上面的目录会在 &lt;code&gt;/usr/lib&lt;/code&gt; 下。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mxnet.io/get_started/setup.html#build-mxnet-on-os-x-mac&#34;&gt;Build MXNet on OS X (Mac)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/dengdan890730/p/5587542.html&#34;&gt;mxnet的python包导入的前前后后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Get the Max Number in Array</title>
      <link>http://nodejh.com/postback/Get-the-Max-Number-in-Array/</link>
      <pubDate>Mon, 24 Oct 2016 19:20:03 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Get-the-Max-Number-in-Array/</guid>
      <description>

&lt;p&gt;本文介绍 JavaScript 的几种从数组中找出最大值的方法。&lt;/p&gt;

&lt;h4 id=&#34;使用递归函数&#34;&gt;使用递归函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var arr = [9,8,55,66,49,68,109,55,33,6,2,1];
var max = arr[0];
function findMax( i ){
  if( i == arr.length ) return max;
  if( max &amp;lt; arr[i] ) max = arr[i];
  findMax(i+1);
}

findMax(1);
console.log(max);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用-for-循环遍历&#34;&gt;使用 for 循环遍历&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var arr = [9,8,55,66,49,68,109,55,33,6,2,1];  
var max = arr[0];
for(var i = 1; i &amp;lt; arr.length; i++){
  if( max &amp;lt; arr[i] ){
    max = arr[i];
  }
}

console.log(max);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用apply将数组传入max方法中直接返回&#34;&gt;使用apply将数组传入max方法中直接返回&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Math.max.apply(null,[9,8,55,66,49,68,109,55,33,6,2,1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，还有很多数组排序方式，都可以在排序后，根据新数组索引值获取 最大/最小 值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a=[1,2,3,5];
console.log(Math.max.apply(null, a));//最大值
console.log(Math.min.apply(null, a));//最小值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多维数组可以这么修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a=[1,2,3,[5,6],[1,4,8]];
var ta=a.join(&amp;quot;,&amp;quot;).split(&amp;quot;,&amp;quot;);//转化为一维数组
console.log(Math.max.apply(null,ta));//最大值
console.log(Math.min.apply(null,ta));//最小值
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Check Parameters in Express Router</title>
      <link>http://nodejh.com/postback/Check-Parameters-in-Express-Router/</link>
      <pubDate>Sat, 15 Oct 2016 06:46:05 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Check-Parameters-in-Express-Router/</guid>
      <description>

&lt;p&gt;本文以 Express 框架为基础，讲诉如何通过一个中间件来检测 Express 路由中传输的参数是否合法。&lt;/p&gt;

&lt;p&gt;几乎对于任何应用，前后端都需要进行传输数据。不管是通过 HTTP 请求的 POST 方法还是 GET 方法，数据校验都是必要的操作。&lt;/p&gt;

&lt;p&gt;对于大部分 API 来说，可能只需要判断传入的参数是否为 undefined 或 null，所以这个时候，为了减少重复代码，我们可以写一个简单的中间件来处理路由中的参数。&lt;/p&gt;

&lt;p&gt;这个中间件的需求如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检测路由中的一般参数是否为 undefined、null、[]、&amp;rdquo;&lt;/li&gt;
&lt;li&gt;中间件同时还需要能对特殊参数做处理，如一个参数值在 1-100 之间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终写出来的处理参数的模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 检测路由中的参数
 * @method checkParameters
 * @param  {object}        req     http请求
 * @param  {object}        res     http响应
 * @param  {Function}      next    
 * @param  {[type]}        special 特殊参数，
 *                                 格式： [{eval: &#39;req.query.id&amp;gt;0&#39;, key:&#39;id&#39;, type: &#39;query&#39;}]
 *                                 key 属性的值必须和eval中对应，且type只能是 query/params/body
 * @return {object}        若参数错误，直接返回json到前端；正确，则next()
 */
function checkParameters(req, res, next, special) {
  // console.log(&#39;params: &#39;, req.params);
  // console.log(&#39;body: &#39;, req.body);
  // console.log(&#39;query: &#39;, req.query);
  console.log(&#39;specialParams: &#39;, typeof special);
  // 判断是否传入第四个参数
  if (Array.isArray(special)) {
    // 判断特殊参数
    for (let i = 0; i &amp;lt; special.length; i++) {
      // console.log(&#39;special[i]: &#39;, special[i]);
      // console.log(&#39;special[i] eval: &#39;, special[i].hasOwnProperty(&#39;eval&#39;));
      // console.log(&#39;special[i] key: &#39;, special[i].hasOwnProperty(&#39;key&#39;));
      // console.log(&#39;special[i] type: &#39;, special[i].hasOwnProperty(&#39;type&#39;));

      // 判断是否具有 eval, key, type 三个参数
      if (! (special[i].hasOwnProperty(&#39;eval&#39;)
        &amp;amp;&amp;amp; special[i].hasOwnProperty(&#39;key&#39;)
        &amp;amp;&amp;amp; special[i].hasOwnProperty(&#39;type&#39;))) {
        return res.json({
          code: 90001,
          msg: &#39;检测参数属否正确时，传入的特殊参数格式不完全&#39;,
          detail: special
        });
      }
      // 判断 eval, key, type 三个参数是否为 undefined
      if ( !(typeof special[i][&#39;eval&#39;] !== undefined
      &amp;amp;&amp;amp; typeof special[i][&#39;key&#39;] !== undefined
      &amp;amp;&amp;amp; typeof special[i][&#39;type&#39;] !== undefined)) {
        return res.json({
          code: 90002,
          msg: &#39;检测参数属否正确时，传入的特殊参数为 undefined&#39;,
          detail: special
        });
      }
      const evalString = special[i][&#39;eval&#39;];
      const type = special[i][&#39;type&#39;];
      const key = special[i][&#39;key&#39;];
      // 判断 key 和 eval 是否匹配
      console.log(&#39;length: &#39;, evalString
      .split(&#39;req.&#39; + type + &#39;.&#39; + key)
      .length);
      const length = evalString.split(&#39;req.&#39; + type + &#39;.&#39; + key).length;
      if (length &amp;lt; 1) {
        return res.json({
          code: 90003,
          msg: &#39;检测参数属否正确时，传入的特殊参数为格式不正确&#39;,
          detail: special
        });
      }
      // 执行 eval
      if (!eval(evalString)) {
        return res.json({
          code: 90004,
          msg: &#39;检测参数属否正确时，参数不匹配传入的条件 &#39; + evalString,
          detail: special,
          parameters: req[type]
        });
      }
      // 从普通参数中删除特殊参数
      // console.log(&#39;delete: &#39;, req[type][key]);
      delete req[type][key];
    }
  }

  const params = req.params;
  // 去掉 req.params 中 {&#39;0&#39;: &#39;&#39;, ...} 这一项
  delete params[&#39;0&#39;];
  // console.log(&#39;params: &#39;, params);
  const body = req.body;
  const query = req.query;
  const common = Object.assign(params, body, query);
  console.log(&#39;common: &#39;, common);
  // 检测参数属否为undefined
  for (let i in common) {
    if (typeof common[i] === &#39;undefined&#39;) {
      return res.json({
        code: 90005,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为undefined&#39;,
        detail: common
      });
    }
    // 检测参数属否为null
    if (common[i] === null) {
      return res.json({
        code: 90006,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为null&#39;,
        detail: common
      });
    }
    // 检测参数是否为空字符串 &#39;&#39;
    if (common[i] === &#39;&#39;) {
      return res.json({
        code: 90007,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为空字符串&#39;,
        detail: common
      });
    }
    // 检测参数是否为空数组 []
    if (common[i] === &#39;&#39;) {
      return res.json({
        code: 90008,
        msg: &#39;检测参数属否正确时，&#39; + i + &#39; 参数为空数组&#39;,
        detail: common
      });
    }
  }

  return next();
}

module.exports = checkParameters;

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数详解&#34;&gt;函数详解&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. 特殊参数的处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个模块，首先对特殊参数做处理。&lt;code&gt;special&lt;/code&gt; 这个参数是一个数组，格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
  eval: &#39;parseInt(req.query.id) &amp;gt; 1 &amp;amp;&amp;amp; parseInt(req.query.id) &amp;lt; 10&#39;,
  key: &#39;id&#39;,
  type: &#39;query&#39;
}, {
  eval: &#39;parseInt(req.query.age) === 11&#39;,
  key: &#39;age&#39;,
  type: &#39;query&#39;
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key 属性的值必须和eval中对应，且type只能是 query/params/body。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先判断函数是否传入第四个参数，并且第四个参数是否为数组，如果这两个条件成立，说明有特殊参数需要处理。&lt;/li&gt;
&lt;li&gt;然后判断是否具有 eval, key, type 三个参数。eval 参数是一个参数条件表达式，如 &amp;lsquo;id&amp;gt;0&amp;rsquo;，最终通过 &lt;code&gt;eval()&lt;/code&gt; 函数来执行这个表达式。&lt;code&gt;key&lt;/code&gt; 表示参数属性名，type 表示是通过何种方式传递的参数，如 query/params/body。&lt;/li&gt;
&lt;li&gt;接下来判断  eval, key, type 三个参数自身是否为 undefined 或 null&lt;/li&gt;
&lt;li&gt;再然后判断 判断 key 和 eval 是否匹配。key 和 eval 的匹配，主要是为了后面从一般参数中删除特殊参数&lt;/li&gt;
&lt;li&gt;再执行 eval 表达式，判断表达式是否成立，即特殊参数值是否合法&lt;/li&gt;
&lt;li&gt;如果以上都为真，说明特殊参数合法，最后则使用 delete 从参数中删除特殊参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 普通参数处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;处理完毕特殊参数后，就需要处理普通参数。普通参数只需要满足：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不为 &lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不为 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不为空字符串 &lt;code&gt;&#39;&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不为空数组 &lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;普通参数，即 &lt;code&gt;req.body&lt;/code&gt; &lt;code&gt;req.params&lt;/code&gt; &lt;code&gt;req.query&lt;/code&gt; 中的所有非特殊参数。&lt;/p&gt;

&lt;p&gt;除了在判断特殊参数的时候，需要 delete 特殊参数，还需要 &lt;code&gt;delete req.params[&#39;0&#39;]&lt;/code&gt;。因为对于 &lt;code&gt;req.params&lt;/code&gt;，当 URL 没有 &lt;code&gt;path&lt;/code&gt; 部分的时候，&lt;code&gt;req.params[&#39;0&#39;]&lt;/code&gt; 为 &lt;code&gt;&#39;&#39;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;处理完毕之后，若所有参数都合法，则返回 &lt;code&gt;next()&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;模块使用&#34;&gt;模块使用&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. 创建没有挂载路径的中间件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先在 Express 项目入口文件，创建一个参数处理中间件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// app.js
const checkParameters = require(&#39;./checkParameters&#39;);
// ...
app.use(function(req, res, next) {
  checkParameters(req, res, next);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的 &lt;code&gt;app.use()&lt;/code&gt; 需要放在创建具体路由中间件如&lt;code&gt;app.use(&#39;/&#39;, index)&lt;/code&gt; 之前。&lt;/p&gt;

&lt;p&gt;当 Express 接收到 HTTP 请求后，首先该中间件会检测参数是否合法（只判断是否为 null 或 undefine 或 &amp;ldquo; 或 []）。如果不合法，则直接返回；如果合法，则程序继续执行，由匹配该请求路径的路由继续完成该请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 创建挂载路径的中间件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果需要对某个路由的特殊参数做处理，则需要创建一个挂载路径的中间件。&lt;/p&gt;

&lt;p&gt;比如为们要判断 &lt;code&gt;/index&lt;/code&gt; 路由的 GET 请求中的 &lt;code&gt;id&lt;/code&gt; 参数，其中 &lt;code&gt;id&lt;/code&gt; 的取值范围是 1-100，URL 形式如 &lt;code&gt;http://localhost:3000/index?id=10&lt;/code&gt;，则可以这样使用该模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
const checkParameters = require(&#39;./checkParameters&#39;);

// 挂载路径的中间件
router.get(&#39;/index&#39;, function(req, res, next) {
  const special = {
    eval: &#39;parseInt(req.query.id) &amp;gt;= 1 &amp;amp;&amp;amp; parseInt(req.query.id) &amp;lt;= 100&#39;,
    key: &#39;id&#39;,
    type: &#39;query&#39;
  };
  checkParameters(req, res, next, special);
});
// 正常逻辑处理
router.get(&#39;/index&#39;, function(req, res, next) {
  // 正常逻辑
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 Express 接收到一个 HTTP 请求的时候，首先还是没有挂载路径的中间件先处理请求，检测参数；然后该挂载路径的中间件再检测参数；最后才执行正常处理逻辑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A simple neural network with Python and Keras</title>
      <link>http://nodejh.com/postback/A-simple-neural-network-with-Python-and-Keras/</link>
      <pubDate>Sun, 09 Oct 2016 18:27:44 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/A-simple-neural-network-with-Python-and-Keras/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&#34;http://www.pyimagesearch.com/2016/09/26/a-simple-neural-network-with-python-and-keras/&#34;&gt;A simple neural network with Python and Keras&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-a-simple-neural-network-with-python-and-keras-1.png&#34; alt=&#34;a-simple-neural-network-with-python-and-keras-1&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-使用-python-and-keras-构建-一个简单的神经网络&#34;&gt;1. 使用 Python and Keras 构建 一个简单的神经网络&lt;/h4&gt;

&lt;p&gt;在开始之前，我们先快速复习一下当前最通用的神经网络架构：前馈网络。&lt;/p&gt;

&lt;p&gt;我们接下来将写一个 Python 代码来定义我们的前馈神经网络，然后将其运用到 Kaggle Dogs vs. Cats(&lt;a href=&#34;https://www.kaggle.com/c/dogs-vs-cats/data&#34;&gt;https://www.kaggle.com/c/dogs-vs-cats/data&lt;/a&gt;) 分类比赛中。这比赛的目标是，给出一张图像，然后区分它是猫还是狗。&lt;/p&gt;

&lt;p&gt;最后，我们将检查我们的神经网络程序的区分结果，然后再讨论一下如何继续优化我们的架构，使结构更精确。&lt;/p&gt;

&lt;h4 id=&#34;2-前馈神经网络&#34;&gt;2. 前馈神经网络&lt;/h4&gt;

&lt;p&gt;目前有很多很多的神经网络架构，其中最通用的一种架构是前馈网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-a-simple-neural-network-with-python-and-keras-2.png&#34; alt=&#34;a-simple-neural-network-with-python-and-keras-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图是一个简单的前馈神经网络示意图，该前馈网络具有三个输入节点，一个具有两个节点的隐藏层，一个具有三个节点的隐藏层，还有两个节点的输出层。&lt;/p&gt;

&lt;p&gt;在这种类型的架构中，要在这两个节点之间建立连接，必须要求这两个节点是 &lt;code&gt;layer i&lt;/code&gt; 中的节点连接到 &lt;code&gt;layer i+1&lt;/code&gt; 中的节点（这也是前馈网络这个术语的由来；前馈网络不允许反向连接，或者层内连接）。&lt;/p&gt;

&lt;p&gt;并且，&lt;code&gt;layer i&lt;/code&gt; 中的节点，必须完全连接（fully connected）到 &lt;code&gt;layer i+1&lt;/code&gt; 中的节点。也就是说，&lt;code&gt;layer i&lt;/code&gt; 中的每一个节点，必须连接到 &lt;code&gt;layer i+1&lt;/code&gt; 中的每个节点。如上图所示，在 layer 0 和 layer 1 中，一共有 2 x 3 = 6 个节点 &amp;mdash; 这就是完全连接（fully connected），或者可以缩写为 &lt;code&gt;FC&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们通常使用一系列的整数来快速简洁地描述每个 layer 中的节点。&lt;/p&gt;

&lt;p&gt;例如，上图的前馈网络，我们可以称之为 &lt;code&gt;3-2-3-2前馈神经网络&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Layer 0 包含 3 个输入，我们可将其定义为 Xi。这些输入值可能是特征矢量的原始像素强度或矢量条目。&lt;/li&gt;
&lt;li&gt;Layer 1 和 Layer 2 是隐藏层（hidden layers），分别包含两个和三个节点。&lt;/li&gt;
&lt;li&gt;Layer 3 是输出节层（output layer），或叫可见层（output layer）。在这里网们将获得神经网络输出的分类。输出层可能有很多输出节点，每一个分类都对应着一个潜在的输出。在  Kaggle Dogs vs. Cats 的分类中，我们有两个输出节点，猫和狗。如果还有其他分类，就会有另一个与之对应的输出节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-使用-python-和-keras-实现我们的神经网络&#34;&gt;3. 使用 Python 和 Keras 实现我们的神经网络&lt;/h4&gt;

&lt;p&gt;现在我们已经理解了前馈神经网络的基本知识，接下来让我们使用  Python 和 Keras 实现我们用于图像分类的神经网络。&lt;/p&gt;

&lt;p&gt;在开始之前，你需要在你的电脑上安装 &lt;code&gt;Keras&lt;/code&gt; 这个框架。&lt;/p&gt;

&lt;p&gt;接下来，新建一个名为 &lt;code&gt;simple_neural_network.py&lt;/code&gt; 的文件，然后开始编码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# import the necessary packages
from sklearn.preprocessing import LabelEncoder
from sklearn.cross_validation import train_test_split
from keras.models import Sequential
from keras.layers import Activation
from keras.optimizers import SGD
from keras.layers import Dense
from keras.utils import np_utils
from imutils import paths
import numpy as np
import argparse
import cv2
import os
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，我们引入我们需要的 Python 的包。我们将使用 scikit-learn 和 Keras 来一起实现我们的函数。在这之前，你最好也需要知道怎么配置开发环境中的 Keras。&lt;/p&gt;

&lt;p&gt;同时我们也需要用刀 &lt;code&gt;imutils&lt;/code&gt; 这个包，这个包可以方便我们使用 OpenCV。如果你还没有安装 imutils，则先安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install imutils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要定义一个函数，来接收图像，并且得到图像的原始像素强度。&lt;/p&gt;

&lt;p&gt;为了完成这个目标，我们先定一个名为 &lt;code&gt;image_to_feature_vector&lt;/code&gt; 的函数，它接受两个输入，一个是 &lt;code&gt;image&lt;/code&gt;，另一个是 &lt;code&gt;size&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def image_to_feature_vector(image, size=(32, 32)):
	# resize the image to a fixed size, then flatten the image into
	# a list of raw pixel intensities
	return cv2.resize(image, size).flatten()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将调整图像，使我们收集到的图像都具有相同的矢量特征大小。这也是我们使用神经网络的一个先决条件，每张图像都必须由一个矢量来表示。&lt;/p&gt;

&lt;p&gt;在这个函数里面，我们需要将图像调整为 32 x 32 像素，然后将图像转化为 32 x 32 x 3 = 3,072-d  的特征矢量。&lt;/p&gt;

&lt;p&gt;接下来的代码，将处理解析命令行参数，注意其中的一些初始化操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# construct the argument parse and parse the arguments
ap = argparse.ArgumentParser()
ap.add_argument(&amp;quot;-d&amp;quot;, &amp;quot;--dataset&amp;quot;, required=True,
	help=&amp;quot;path to input dataset&amp;quot;)
args = vars(ap.parse_args())

# grab the list of images that we&#39;ll be describing
print(&amp;quot;[INFO] describing images...&amp;quot;)
imagePaths = list(paths.list_images(args[&amp;quot;dataset&amp;quot;]))

# initialize the data matrix and labels list
data = []
labels = []

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用 &lt;code&gt;--dataset&lt;/code&gt; 参数来定义输入  Kaggle Dogs vs. Cats 图像的目录。这些图像图可以从 &lt;a href=&#34;https://www.kaggle.com/c/dogs-vs-cats/data&#34;&gt;https://www.kaggle.com/c/dogs-vs-cats/data&lt;/a&gt; 这里下载。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;imagePaths = list(paths.list_images(args[&amp;quot;dataset&amp;quot;]))&lt;/code&gt; 这一行用来收集输入的图像。第 31 行 和第 32 分别初始化 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;labels&lt;/code&gt; 列表。&lt;/p&gt;

&lt;p&gt;现在我们已经有了 &lt;code&gt;imagePaths&lt;/code&gt;，接下来就可以循环处理它们中的每一项，把图像转换为特征矢量，然后将其添加到 &lt;code&gt;data&lt;/code&gt;  和 &lt;code&gt;labels&lt;/code&gt; 列表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# loop over the input images
for (i, imagePath) in enumerate(imagePaths):
	# load the image and extract the class label (assuming that our
	# path as the format: /path/to/dataset/{class}.{image_num}.jpg
	image = cv2.imread(imagePath)
	label = imagePath.split(os.path.sep)[-1].split(&amp;quot;.&amp;quot;)[0]

	# construct a feature vector raw pixel intensities, then update
	# the data matrix and labels list
	features = image_to_feature_vector(image)
	data.append(features)
	labels.append(label)

	# show an update every 1,000 images
	if i &amp;gt; 0 and i % 1000 == 0:
		print(&amp;quot;[INFO] processed {}/{}&amp;quot;.format(i, len(imagePaths)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 &lt;code&gt;data&lt;/code&gt; 列表包含每个输入图像的扁平化  32 x 32 x 3 = 3,072-d 表示。当然，在我们开始训练我们的神经网络之前，我们首先要做一些预处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# encode the labels, converting them from strings to integers
le = LabelEncoder()
labels = le.fit_transform(labels)

# scale the input image pixels to the range [0, 1], then transform
# the labels into vectors in the range [0, num_classes] -- this
# generates a vector for each label where the index of the label
# is set to `1` and all other entries to `0`
data = np.array(data) / 255.0
labels = np_utils.to_categorical(labels, 2)

# partition the data into training and testing splits, using 75%
# of the data for training and the remaining 25% for testing
print(&amp;quot;[INFO] constructing training/testing split...&amp;quot;)
(trainData, testData, trainLabels, testLabels) = train_test_split(
	data, labels, test_size=0.25, random_state=42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data = np.array(data) / 255.0&lt;/code&gt; 行将输入的数据范围调整到 [0, 1] 之间，&lt;code&gt;labels = np_utils.to_categorical(labels, 2)&lt;/code&gt;  这一行将整数转换为矢量（在我们训练神经网络的交叉熵损失函数中需要用到）。&lt;/p&gt;

&lt;p&gt;接下来的两行，我们就开始初始化我们的训练和测试代码，75% 的数据用来训练，25% 的数据用来测试。&lt;/p&gt;

&lt;p&gt;现在我们将使用 Keras 来定义我们的神经网络：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# define the architecture of the network
model = Sequential()
model.add(Dense(768, input_dim=3072, init=&amp;quot;uniform&amp;quot;,
	activation=&amp;quot;relu&amp;quot;))
model.add(Dense(384, init=&amp;quot;uniform&amp;quot;, activation=&amp;quot;relu&amp;quot;))
model.add(Dense(2))
model.add(Activation(&amp;quot;softmax&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码就即用来构建我们的神经网络结构，一个 3072-768-384-2 前馈神经网络。&lt;/p&gt;

&lt;p&gt;我们的 input layer 有 3072 个节点，在我们输入的扁平化图像厘米，每个节点有 32 x 32 x 3 = 3,072 个原始像素强度。&lt;/p&gt;

&lt;p&gt;我们也有两个 hidden layer，分别有 768 和 384 个节点。这些节点的数目通过交叉验证和调整超参数实验来确定。&lt;/p&gt;

&lt;p&gt;Output layer 包含两个节点，分别是猫和狗的类标签。&lt;/p&gt;

&lt;p&gt;我们将在网络的顶部定义一个名为 &lt;code&gt;softmax&lt;/code&gt; 的函数，这个函数将会得出实际输出类标签的概率。&lt;/p&gt;

&lt;p&gt;接下来将使用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Stochastic_gradient_descent&#34;&gt;Stochastic Gradient Descent (SGD)&lt;/a&gt; 来训练我们的模型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# train the model using SGD
print(&amp;quot;[INFO] compiling model...&amp;quot;)
sgd = SGD(lr=0.01)
model.compile(loss=&amp;quot;binary_crossentropy&amp;quot;, optimizer=sgd,
	metrics=[&amp;quot;accuracy&amp;quot;])
model.fit(trainData, trainLabels, nb_epoch=50, batch_size=128,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了训练我们的模型，我们将SGD的学习率参数设定为0.01。我们将使用 binary_crossentropy 损失函数也是如此。&lt;/p&gt;

&lt;p&gt;在大多数情况下，你需要使用交叉熵 &lt;code&gt;crossentropy&lt;/code&gt; ，但由于只有两个类标签，所以我们使用 &lt;code&gt;binary_crossentropy&lt;/code&gt;。如果类标签数量大于 2，请确保使用交叉熵。&lt;/p&gt;

&lt;p&gt;这个网络允许对 50 epochs 进行训练，意味着模型将看到对每个图片单独进行 50 次训练，以便了解底层的图案。&lt;/p&gt;

&lt;p&gt;最后的代码块评估我们的Keras神经网络的测试数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# show the accuracy on the testing set
print(&amp;quot;[INFO] evaluating on testing set...&amp;quot;)
(loss, accuracy) = model.evaluate(testData, testLabels,
	batch_size=128, verbose=1)
print(&amp;quot;[INFO] loss={:.4f}, accuracy: {:.4f}%&amp;quot;.format(loss,
	accuracy * 100))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-使用构建的神经网络来分类图片&#34;&gt;4. 使用构建的神经网络来分类图片&lt;/h4&gt;

&lt;p&gt;为了使用 &lt;code&gt;simple_neural_network.py&lt;/code&gt; 这个脚本，请确保：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用完整代码&lt;/li&gt;
&lt;li&gt;下载  Kaggle Dogs vs. Cats &lt;a href=&#34;[https://www.kaggle.com/c/dogs-vs-cats/data](https://www.kaggle.com/c/dogs-vs-cats/data)&#34;&gt;&lt;a href=&#34;https://www.kaggle.com/c/dogs-vs-cats/data&#34;&gt;https://www.kaggle.com/c/dogs-vs-cats/data&lt;/a&gt;&lt;/a&gt;  的图像，并保存在某个目录如 kaggle_dogs_vs_cats&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# USAGE
# python simple_neural_network.py --dataset kaggle_dogs_vs_cats

# import the necessary packages
from sklearn.preprocessing import LabelEncoder
from sklearn.cross_validation import train_test_split
from keras.models import Sequential
from keras.layers import Activation
from keras.optimizers import SGD
from keras.layers import Dense
from keras.utils import np_utils
from imutils import paths
import numpy as np
import argparse
import cv2
import os

def image_to_feature_vector(image, size=(32, 32)):
	# resize the image to a fixed size, then flatten the image into
	# a list of raw pixel intensities
	return cv2.resize(image, size).flatten()

# construct the argument parse and parse the arguments
ap = argparse.ArgumentParser()
ap.add_argument(&amp;quot;-d&amp;quot;, &amp;quot;--dataset&amp;quot;, required=True,
	help=&amp;quot;path to input dataset&amp;quot;)
args = vars(ap.parse_args())

# grab the list of images that we&#39;ll be describing
print(&amp;quot;[INFO] describing images...&amp;quot;)
imagePaths = list(paths.list_images(args[&amp;quot;dataset&amp;quot;]))

# initialize the data matrix and labels list
data = []
labels = []

# loop over the input images
for (i, imagePath) in enumerate(imagePaths):
	# load the image and extract the class label (assuming that our
	# path as the format: /path/to/dataset/{class}.{image_num}.jpg
	image = cv2.imread(imagePath)
	label = imagePath.split(os.path.sep)[-1].split(&amp;quot;.&amp;quot;)[0]

	# construct a feature vector raw pixel intensities, then update
	# the data matrix and labels list
	features = image_to_feature_vector(image)
	data.append(features)
	labels.append(label)

	# show an update every 1,000 images
	if i &amp;gt; 0 and i % 1000 == 0:
		print(&amp;quot;[INFO] processed {}/{}&amp;quot;.format(i, len(imagePaths)))

# encode the labels, converting them from strings to integers
le = LabelEncoder()
labels = le.fit_transform(labels)

# scale the input image pixels to the range [0, 1], then transform
# the labels into vectors in the range [0, num_classes] -- this
# generates a vector for each label where the index of the label
# is set to `1` and all other entries to `0`
data = np.array(data) / 255.0
labels = np_utils.to_categorical(labels, 2)

# partition the data into training and testing splits, using 75%
# of the data for training and the remaining 25% for testing
print(&amp;quot;[INFO] constructing training/testing split...&amp;quot;)
(trainData, testData, trainLabels, testLabels) = train_test_split(
	data, labels, test_size=0.25, random_state=42)

# define the architecture of the network
model = Sequential()
model.add(Dense(768, input_dim=3072, init=&amp;quot;uniform&amp;quot;,
	activation=&amp;quot;relu&amp;quot;))
model.add(Dense(384, init=&amp;quot;uniform&amp;quot;, activation=&amp;quot;relu&amp;quot;))
model.add(Dense(2))
model.add(Activation(&amp;quot;softmax&amp;quot;))

# train the model using SGD
print(&amp;quot;[INFO] compiling model...&amp;quot;)
sgd = SGD(lr=0.01)
model.compile(loss=&amp;quot;binary_crossentropy&amp;quot;, optimizer=sgd,
	metrics=[&amp;quot;accuracy&amp;quot;])
model.fit(trainData, trainLabels, nb_epoch=50, batch_size=128,
	verbose=1)

# show the accuracy on the testing set
print(&amp;quot;[INFO] evaluating on testing set...&amp;quot;)
(loss, accuracy) = model.evaluate(testData, testLabels,
	batch_size=128, verbose=1)
print(&amp;quot;[INFO] loss={:.4f}, accuracy: {:.4f}%&amp;quot;.format(loss,
	accuracy * 100))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，就可以像下面这样运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python simple_neural_network.py --dataset kaggle_dogs_vs_cats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后的程序输出如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-a-simple-neural-network-with-python-and-keras-3.png&#34; alt=&#34;a-simple-neural-network-with-python-and-keras-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在我的 Titan X GPU 的电脑上，整个程序的执行，包括特征提取、训练神经网络、评估测试数据，一共花了 1m 15s。训练数据的准确率大约为 76%，测试数据的准确率大约为 67%。&lt;/p&gt;

&lt;p&gt;大概 9% 的准确率差异，也是很常见的，这跟训练测试精度，和有限的测试数据相关。&lt;/p&gt;

&lt;p&gt;在上面的程序中，我们最终获得了 67.376％ 的精度，这也是比较高的精度了。当然，我们还可以很容易地通过使用卷积神经网络获得大于 95％ 的准确率。&lt;/p&gt;

&lt;h4 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h4&gt;

&lt;p&gt;在上面的内容中，我示范了如何通过 Python and Keras 来构建和训练神经网络。我们将神经网络运用到了 Kaggle Dogs vs. Cats 的测试中，仅仅通过每张图片的原始像素强度，我们就最终得到了  67.376% 的精度。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Crawler for SCU Libirary</title>
      <link>http://nodejh.com/postback/Crawler-for-SCU-Libirary/</link>
      <pubDate>Fri, 07 Oct 2016 01:03:30 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Crawler-for-SCU-Libirary/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文详细讲述如何模拟登录某某大学图书馆系统&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么说是某某大学？往下看了就知道了 😉&lt;/p&gt;

&lt;p&gt;对于爬虫程序，如果需要抓取的页面，需要登录后才能访问，这时一般就需要进行模拟登录了。由于最近需要抓取登录四川大学图书馆后的一些信息，所以以此为例详细说明整个分析和编码过程。&lt;/p&gt;

&lt;p&gt;总的来说，对于一般系统的模拟登录分为三大步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分析页面，得到登录 URL 和所需要传递的数据&lt;/li&gt;
&lt;li&gt;通过程序向所得 URL 发送数据&lt;/li&gt;
&lt;li&gt;根据服务端的响应判断是否登录成功，若登录成功，则保存返回的 cookie&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只要得到了 cookie，当需要抓取登陆后才能访问的页面时，只需要发送 HTTP 请求时，在 HTTP Header 带上 cookie 即可。&lt;/p&gt;

&lt;p&gt;对于写爬虫程序，还有一些小技巧（其实目前就总结出来一个）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;能抓取手机站就抓取手机站，因为手机网站一般比较容易&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-分析四川大学移动图书馆&#34;&gt;1. 分析四川大学移动图书馆&lt;/h3&gt;

&lt;h4 id=&#34;1-1-分析&#34;&gt;1.1. 分析&lt;/h4&gt;

&lt;p&gt;图书馆系统有一个手机网站，所以优先选择手机站作为目标。其链接是 &lt;a href=&#34;http://m.5read.com/395&#34;&gt;http://m.5read.com/395&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先看到这个链接的时候，我也是比较奇怪，毕竟这个域名就比较奇怪，川大图书馆系统手机版的域名为什么不是 &lt;a href=&#34;http://scu.edu.cn&#34;&gt;scu.edu.cn&lt;/a&gt; 的子域名，而且域名的 &lt;code&gt;PATH&lt;/code&gt; 部分为什么是 &lt;code&gt;395&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;域名打开后是 &lt;code&gt;四川大学移动图书馆&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-com-scu-lib.png&#34; alt=&#34;crawler-for-scu-lib-1-com-scu-lib.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后我把 &lt;code&gt;395&lt;/code&gt; 去掉，直接输入了 &lt;code&gt;http://m.5read.com&lt;/code&gt;，打开也是川大图书馆首页。但如果我在另一个没有打开过该链接的浏览器中打开 &lt;code&gt;http://m.5read.com/&lt;/code&gt; ，则是 &lt;code&gt;默认单位移动图书馆&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-com-default-lib.png&#34; alt=&#34;crawler-for-scu-lib-1-com-default-lib.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候就得出两个猜测：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一是 URL 中的 &lt;code&gt;395&lt;/code&gt; 是学校的编号&lt;/li&gt;
&lt;li&gt;二是打开 &lt;code&gt;http://m.5read.com/395&lt;/code&gt; 后，客户端肯定会生成对应的 cookies ，表示当前客户端访问的是 &lt;code&gt;395&lt;/code&gt; 这所大学的图书馆系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了验证第一个猜测，我们把 &lt;code&gt;395&lt;/code&gt; 改为任意一个其他数字。这样大概有两种情况，如 &lt;code&gt;http://m.5read.com/1&lt;/code&gt;则提示 &lt;code&gt;对不起，还没有开通手机业务！&lt;/code&gt;，&lt;code&gt;http://m.5read.com/20&lt;/code&gt; 则是厦门大学的图书馆系统，见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-com-1-not-dredge.png&#34; alt=&#34;crawler-for-scu-lib-1-com-1-not-dredge.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-com-20-xmu.png&#34; alt=&#34;crawler-for-scu-lib-1-com-20-xmu.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来再看看是不是生成了对应的 cookie 信息。在 Chrome 的 &lt;code&gt;开发者工具 -&amp;gt; Application&lt;/code&gt; 的左侧菜单栏选中 &lt;code&gt;Cookies&lt;/code&gt;，然后在右侧选中某个 cookie，并点击右键，选择 &lt;code&gt;Clear All&lt;/code&gt; 清除所有 cookies。也可以直接在左侧菜单栏 &lt;code&gt;Cookies&lt;/code&gt; 展开后的域名上，点击右键，选择 &lt;code&gt;clear&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-clear-cache.png&#34; alt=&#34;crawler-for-scu-lib-1-clear-cache.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为我的目的是模拟模拟登录四川大学图书馆系统，所以我还是先访问 &lt;code&gt;http://m.5read.com/395&lt;/code&gt;，再来看看 cookies：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-cookies-scu.png&#34; alt=&#34;crawler-for-scu-lib-1-cookies-scu.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，的确生成了 cookies，结构和之前厦门大学类似。为了弄清楚 cookies 是怎么生成的，接下来要查看的就是 HTTP 请求的详细内容了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-http-request.png&#34; alt=&#34;crawler-for-scu-lib-1-http-request.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以发现，Response Headers 里面有很多 &lt;code&gt;Set-Cookie&lt;/code&gt; 字段。请求头中没有特殊的字段。所以访问 &lt;code&gt;http://m.5read.com/395&lt;/code&gt; 的大致流程是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器（客户端）发起 HTTP 请求，请求的 URL 地址是 &lt;code&gt;http://m.5read.com/395&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端接收到请求，并根据 URL 中的 &lt;code&gt;395&lt;/code&gt; 参数，分析得出访问的是 &lt;code&gt;四川大学移动图书馆&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端根据 &lt;code&gt;395&lt;/code&gt; 在响应头信息中加入对应的 &lt;code&gt;set-cookie&lt;/code&gt; 字段&lt;/li&gt;
&lt;li&gt;浏览器接收到服务端的响应，并根据响应头中的 &lt;code&gt;Set-Cookie&lt;/code&gt; 字段，生成对应的 cookies&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果要访问 &lt;code&gt;四川大学移动图书馆&lt;/code&gt; 的其他页面，必然也要带上这些 cookies，不然系统无法区分访问的是那个大学的移动图书馆。&lt;/p&gt;

&lt;h4 id=&#34;1-2-结论&#34;&gt;1.2 结论&lt;/h4&gt;

&lt;p&gt;根据以上分析，得出结论如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://m.5read.com/395&lt;/code&gt; 表示某个学校移动图书馆的首页，URL 中的 &lt;code&gt;395&lt;/code&gt; 参数表示学校代码&lt;/li&gt;
&lt;li&gt;访问不同学校的移动图书馆首页，会生成对应的 cookies&lt;/li&gt;
&lt;li&gt;当需求访问某学校移动图书馆系统的其他页面时，必须带上访问首页时生成的 cookies&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-3-代码&#34;&gt;1.3 代码&lt;/h4&gt;

&lt;p&gt;我用的 Node.js 的 request 这个包来发送 HTTP 请求。在使用前，需要先安装： &lt;code&gt;npm install request --save&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const request = require(&#39;request&#39;);
const options = {
  url: &#39;http://m.5read.com/395&#39;
};
request(options, (error, response, body) =&amp;gt; {
  if (error) {
    console.error(&#39;访问首页失败: \n&#39;, error);
    return { error };
  }
  const cookie = response.headers[&#39;set-cookie&#39;];
  console.log(&#39;cookie:\n &#39;, cookie);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序运行后，如果没出错，则会以标准输出的形式输出 cookies：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node index.js
cookie:
  [ &#39;JSESSIONID=E2741DEB3D5296EF15A1F8914E92EE77.irdmblhome72b; Path=/; HttpOnly&#39;,
  &#39;DSSTASH_LOG=C%5f4%2dUN%5f395%2dUS%5f%2d1%2dT%5f1475793477551; Domain=.5read.com; Path=/&#39;,

  &#39;mgid=274; Domain=.5read.com; Expires=Sat, 05-Nov-2016 22:37:57 GMT; Path=/&#39;,
  &#39;maid=395; Domain=.5read.com; Expires=Sat, 05-Nov-2016 22:37:57 GMT; Path=/&#39;,
  &#39;msign_dsr=1475793477609; Domain=.5read.com; Expires=Wed, 01-Oct-2036 22:37:57 GMT; Path=/&#39;,
  &#39;mduxiu=musername%2c%3dblmobile%2c%21muserid%2c%3d1000086%2c%21mcompcode%2c%3d1009%2c%21menc%2c%3d26546915E1F9381939EA005CB06A28F6; Domain=.5read.com; Expires=
Sat, 05-Nov-2016 22:37:57 GMT; Path=/&#39;,
  &#39;xc=6; Domain=.5read.com; Expires=Sat, 05-Nov-2016 22:37:57 GMT; Path=/&#39; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-分析登录页面&#34;&gt;2. 分析登录页面&lt;/h3&gt;

&lt;h4 id=&#34;2-1-分析&#34;&gt;2.1 分析&lt;/h4&gt;

&lt;p&gt;接下来需要寻找的就是对应的登录页面。登录页面的 URL是 &lt;code&gt;http://mc.m.5read.com/user/login/showLogin.jspx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;打开该页面，再看看 HTTP 请求：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-1-cookies-send-scu.png&#34; alt=&#34;crawler-for-scu-lib-1-cookies-send-scu.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以发现，发送请求头中的 Cookie 为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DSSTASH_LOG=C%5f4%2dUN%5f395%2dUS%5f%2d1%2dT%5f1475781232585; mgid=274; maid=395; msign_dsr=1475781232606; mduxiu=musername%2c%3dblmobile%2c%21muserid%2c%3d1000086%2c%21mcompcode%2c%3d1009%2c%21menc%2c%3d13A4F68ACE9126AA111D239F62C09038; xc=5; Hm_lvt_d2fe4972d5c5737ef70e82fe0c8deaee=1475781234; Hm_lpvt_d2fe4972d5c5737ef70e82fe0c8deaee=1475781234
Host:mc.m.5read.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中不包含 &lt;code&gt;JSESSIONID&lt;/code&gt;，而响应头中返回了一个新的 &lt;code&gt;Set-Cookie:JSESSIONID=9C04830620D2783E63E852BC67AE031D.irdmbl72a; Path=/; HttpOnly&lt;/code&gt; 字段。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JSESSIONID&lt;/code&gt; 是 Tomcat 中的 SESSIONID，主要作用是用来标识当前请求对应的用户。SESSIONID 是唯一的。当客户端访问服务器时，服务器（这里是 Tomcat）会生成一个唯一的 SESSIONID（这里是 JSESSIONID），并返回给客户端，客户端将 SESSIONID 保存在 cookie 中。之后客户端再发送 HTTP 请求时，就会在 HTTP Headers 中以 cookie 的形式发送 SESSIONID 到服务器。服务器接收到 SESSIONID 后，就可以根据 SESSIONID 来判断是哪一个客户端发送的请求。&lt;/p&gt;

&lt;p&gt;对于该图书馆系统，访问首页 &lt;a href=&#34;http://m.5read.com/395&#34;&gt;http://m.5read.com/395&lt;/a&gt; 和访问登录页 &lt;a href=&#34;http://mc.m.5read.com/user/login/showLogin.jspx&#34;&gt;http://mc.m.5read.com/user/login/showLogin.jspx&lt;/a&gt; 是生成的不同的 &lt;code&gt;JSESSIONID&lt;/code&gt;，说明该系统认为访问这两个页面是不同的用户，即使事实上是同一个用户访问的。&lt;/p&gt;

&lt;p&gt;从 &lt;code&gt;JSESSIONID&lt;/code&gt; 的作用来看，&lt;code&gt;JSESSIONID&lt;/code&gt; 和用户登录没有直接关系。所以模拟登录的时候，依旧只需要使用访问首页时生成的 cookie 即可。怎么验证呢？可以在 Chrome 开发者工具的 &lt;code&gt;Application&lt;/code&gt; 面板中，找到 cookie 里面的 &lt;code&gt;JSESSIONID&lt;/code&gt; 字段，并删除，然后刷新页面，会发现又生成了另一个新的 &lt;code&gt;JSESSIONID&lt;/code&gt;。所以不论 &lt;code&gt;JSESSIONID&lt;/code&gt; 是什么值，我们都可以登录。所以 &lt;code&gt;JSESSIONID&lt;/code&gt; 不会影响模拟登录。&lt;/p&gt;

&lt;h4 id=&#34;2-2-结论&#34;&gt;2.2 结论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;进行模拟登录，和用户登录有关的 cookie 信息是访问首页时生成的 cookie&lt;/li&gt;
&lt;li&gt;访问首页和登录页面时，&lt;code&gt;JSESSIONID&lt;/code&gt; 虽然会发生变化，但 &lt;code&gt;JSESSIONID&lt;/code&gt; 并不会影响用户通过账号和密码进行认证&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-3-代码&#34;&gt;2.3 代码&lt;/h4&gt;

&lt;p&gt;这部分没有直接的代码。但因为接下来要进行模拟登录，所以肯定又会再写一个 &lt;code&gt;request&lt;/code&gt; 发送 HTTP 请求，所以现在可以把之前的代码结构优化一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// login.js

const request = require(&#39;request&#39;);


const errorText = {
  account: &#39;用户名或密码错误&#39;,
  emptyPassword: &#39;借阅证密码不能为空&#39;,
  emptyNumber: &#39;借阅证号不能为空&#39;,
};
const url = {
  // 图书馆手机首页
  home: &#39;http://m.5read.com/395&#39;,
  // 登陆 URL
  login: &#39;http://mc.m.5read.com/irdUser/login/opac/opacLogin.jspx&#39;,
};
const regexp = {
  number: number: /^\d+$/,
};


/**
 * 获取 cookie
 * @method getCookie
 * @param  {object}   options  HTTP请求设置信息
 * @param  {Function} callback
 * @return {string}   {error, HTTP响应中的cookie}
 */
const getCookie = (options, callback) =&amp;gt; {
  request(options, (error, response) =&amp;gt; {
    if (error) {
      return callback({ error, code: 1018 });
    }
    const cookie = response.headers[&#39;set-cookie&#39;].join();
    return callback(null, cookie);
  });
};


getCookie({url: url.home}, (error, resHome) =&amp;gt; {
  if (error) {
    console.error(&#39;获取首页 cookie 失败: \n&#39;, error);
    return false;
  }
  const cookieHome = resHome.cookie;
  console.log(&#39;首页cookie:\n &#39;, cookieHome);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-模拟登录&#34;&gt;3. 模拟登录&lt;/h3&gt;

&lt;h4 id=&#34;3-1-分析&#34;&gt;3.1 分析&lt;/h4&gt;

&lt;p&gt;前面做了那么多分析，主要就是为了登录的时候，发送正确的 cookie。在最终模拟登录之前，还需要做一点分析。&lt;/p&gt;

&lt;p&gt;现在需要做的就是，通过学号和密码登录，并继续查看 HTTP 请求，找到登录认证的接口,并分析请求头和响应头。&lt;/p&gt;

&lt;p&gt;下面是我输入正确的学号和密码之后，HTTP 请求：&lt;/p&gt;

&lt;p&gt;请求头：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-2-scu-request-header.png&#34; alt=&#34;crawler-for-scu-lib-2-scu-request-header.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;响应头：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-2-scu-response-header.png&#34; alt=&#34;crawler-for-scu-lib-2-scu-response-header.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-crawler-for-scu-lib-2-scu-request-data.png&#34; alt=&#34;crawler-for-scu-lib-2-scu-request-data.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从请求头中可以发现，用户登录的 URL 是  &lt;code&gt;http://mc.m.5read.com/irdUser/login/opac/opacLogin.jspx&lt;/code&gt;，HTTP Method 是 &lt;code&gt;POST&lt;/code&gt;，需要传递的数据是 &lt;code&gt;schoolid=学校编号&amp;amp;backurl=&amp;amp;userType=0&amp;amp;username=xxxxxx&amp;amp;password=xxx&lt;/code&gt;，并且是通过表单的方式传递的数据：&lt;code&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt;。当然，发送 HTTP 请求时，请求头中还有 cookie。除了 &lt;code&gt;JSESSIONID&lt;/code&gt; 是新生成之外，其余 cookie 都是访问首页时生成的。&lt;/p&gt;

&lt;p&gt;登录成功后，再去查看 cookie ，就会发现 cookie 已经更新为响应头中 &lt;code&gt;set-cookie&lt;/code&gt; 中的字段和值了。&lt;/p&gt;

&lt;h4 id=&#34;3-2-结论&#34;&gt;3.2 结论&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;URL: http://mc.m.5read.com/irdUser/login/opac/opacLogin.jspx
Method: POST
Content-Type:application/x-www-form-urlencoded
Cookie: ...               // 访问首页时生成的 cookie
Form Data: {
  schoolid:395,           // 学校代码
  backurl: &#39;&#39;             // 登录后跳转的 URL
  userType: 0,            // 登录时的账号类型，0 表示学号密码登录
  username: 000000000000, // 学号
  password: 000000,        // 密码
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-代码&#34;&gt;3.3 代码&lt;/h4&gt;

&lt;p&gt;登录模块的完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// login.js

const request = require(&#39;request&#39;);


const errorText = {
  account: &#39;用户名或密码错误&#39;,
  emptyPassword: &#39;借阅证密码不能为空&#39;,
  emptyNumber: &#39;借阅证号不能为空&#39;,
};
const schoolid = 395;
const url = {
  // 图书馆手机首页
  home: &#39;http://m.5read.com/395&#39;,
  // 登陆 URL
  login: &#39;http://mc.m.5read.com/irdUser/login/opac/opacLogin.jspx&#39;,
};
const regexp = {
  number: /^\d+$/,
};


/**
 * 获取 cookie
 * @method getCookie
 * @param  {object}   options  HTTP请求设置信息
 * @param  {Function} callback
 * @return {string}   {error, HTTP响应中的cookie}
 */
const getCookie = (options, callback) =&amp;gt; {
  request(options, (error, response) =&amp;gt; {
    if (error) {
      return callback({ error, code: 1018 });
    }
    const cookie = response.headers[&#39;set-cookie&#39;].join();
    return callback(null, cookie);
  });
};


/**
 * 模拟登录操作
 * @method doLogin
 * @param  {object}   options  HTTP 请求信息
 * @param  {string}   cookie   cookie
 * @param  {Function} callback 回调函数
 * @return {object}   {error, 登录成功后的cookie}
 */
const doLogin = (options, callback) =&amp;gt; {
  request(options, (error, response, body) =&amp;gt; {
    if (error) {
      return callback({ error });
    }
    if (body.indexOf(errorText.account) !== -1) {
      return callback({
        error: errorText.account,
        code: 1019,
      });
    }
    if (body.indexOf(errorText.emptyPassword) !== -1) {
      return callback({
        error: errorText.emptyPassword,
        code: 1020,
      });
    }
    if (body.indexOf(errorText.emptyNumber) !== -1) {
      return callback({
        error: website.errorText.emptyNumber,
        code: 1021,
      });
    }
    const cookieLogined = response.headers[&#39;set-cookie&#39;].join();
    return callback(null, cookieLogined);
  });
};


/**
 * 模拟登录
 * @method login
 * @param  {string}   number   学号（借阅证号）
 * @param  {string}   password 密码
 * @param  {Function} callback 回调函数
 * @return {object}   登录成功后的cookie
 */
const login = (number, password, callback) =&amp;gt; {
  // 验证 number
  if (!regexp.number.test(number)) {
    return callback({ code: 1016, error: &#39;登录移动图书馆学号格式错误&#39; });
  }
  // 验证 password
  if (!regexp.number.test(password)) {
    return callback({ code: 1017, error: &#39;登录移动图书馆密码格式错误&#39; });
  }
  // 获取图书馆首页 cookie
  getCookie({ url: url.home }, (errHome, cookieHome) =&amp;gt; {
    if (errHome) {
      console.log(&#39;获取图书馆首页 cookie 失败: \n&#39;, errHome);
      return callback({
        code: errHome.code,
        error: errHome.error,
      });
    }
    console.log(&#39;首页cookie:\n &#39;, cookieHome);
    // 模拟登录
    const options = {
      url: url.login,
      form: {
        schoolid: schoolid,
        backurl: &#39;&#39;,
        userType: 0,
        username: number,
        password,
      },
      headers: {
        Cookie: cookieHome,
        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
      },
      method: &#39;POST&#39;,
    };
    doLogin(options, (errLogin, cookieLogined) =&amp;gt; {
      if (errLogin) {
        console.log(&#39;登录失败: \n&#39;, errLogin);
        return callback({
          code: errLogin.code,
          error: errLogin.error,
        });
      }
      console.log(&#39;登录成功后的 cookie:\n &#39;, cookieLogined);
      return callback(null, cookieLogined);
    });
  });
};


module.exports = login;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-抓取借阅信息&#34;&gt;4. 抓取借阅信息&lt;/h3&gt;

&lt;p&gt;为了验证登录后的 cookie 是不是最终正确，访问一下需要登录后才能访问的页面即可。&lt;/p&gt;

&lt;p&gt;所以下面就来抓取借阅信息。为了解析 HTML 文本，我们还需要用到 &lt;a href=&#34;https://github.com/cheeriojs/cheerio&#34;&gt;cheerio&lt;/a&gt; 这个包。cheerio 就相当于是服务端的 jQuery，可以像使用 jQuery 选择器一样从一个 HTML 文本中取出想要的内容。&lt;/p&gt;

&lt;p&gt;新建一个 &lt;code&gt;get_books.js&lt;/code&gt; 文件，添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// get_books.js
const request = require(&#39;request&#39;);
const cheerio = require(&#39;cheerio&#39;);
const login = require(&#39;./login&#39;);

const url = {
  books: &#39;http://mc.m.5read.com/cmpt/opac/opacLink.jspx?stype=1&#39;,
}
const errorText = {
  cookieTips: &#39;请确认您的浏览器Cookie开启和正常访问移动图书馆首页&#39;
};

const number = &#39;0000000000000&#39;; // 学号（借阅证号）
const password = &#39;000000&#39;;  // 密码

const fetchBooks = (cookie, callback) =&amp;gt; {
  const options = {
    url: url.books,
    headers: {
      Cookie: cookie,
    },
  };

  request(options, (error, response, body) =&amp;gt; {
    if (error) {
      console.log(&#39;获取图书借阅列表失败: &#39;, error);
      return callback({
        code: 1025,
        error: &#39;获取图书借阅列表失败&#39;,
        detail: error,
      });
    }
    console.log(&#39;response.statusCode: &#39;, response.statusCode);
    if (response.statusCode !== 200) {
      return callback({
        code: 1026,
        error: &#39;获取图书借阅列表失败&#39;,
        detail: response,
      });
    }
    return callback(null, body);
  });
};


const parseBooks = (html, callback) =&amp;gt; {
  if (html.indexOf(errorText.cookieTips) !== -1) {
    console.log(errorText.cookieTips);
    return {
      code: 1027,
      error: &#39;移动图书馆系统 cookie 信息过期，请重新登录&#39;,
      detail: html,
    };
  }
  const $ = cheerio.load(html, {
    ignoreWhitespace: true,
    xmlMode: false,
    lowerCaseTags: false,
  });
  const domBooks = $(&#39;.boxBd&#39;).find(&#39;.sheet&#39;);
  const booksNumber = domBooks.length; // 借阅数量
  // console.log(domBooks.length);
  const books = [];
  domBooks.each(function () {
    const barCodeValue = $(this).find(&#39;td&#39;).eq(5).find(&#39;form input&#39;)
        .eq(0)
        .attr(&#39;value&#39;);
    const borIdValue = $(this).find(&#39;td&#39;).eq(5).find(&#39;form input&#39;)
        .eq(1)
        .attr(&#39;value&#39;);
    books.push({
      // 作者
      author: $(this).find(&#39;td&#39;).eq(0).text(),
      // 书名
      name: $(this).find(&#39;td&#39;).eq(1).text(),
      // 应还日期
      expiredate: $(this).find(&#39;td&#39;).eq(2).text(),
      // 分馆
      libraryBranch: $(this).find(&#39;td&#39;).eq(3).text(),
      // 索书号
      number: $(this).find(&#39;td&#39;).eq(4).text(),
      borId: borIdValue,
      barCode: barCodeValue,
    });
  });
  return callback(null, {
    booksNumber,
    books,
  });
};

login(number, password, (error, cookie) =&amp;gt; {
  if (error) {
    return console.log(error);
  }
  // 获取借阅列表页面html
  fetchBooks(cookie, (errFetch, resFetch) =&amp;gt; {
    if (errFetch) {
      return console.log(errFetch);
    }
    // 解析借阅列表html
    parseBooks(resFetch, (errParse, resParse) =&amp;gt; {
      if (errParse) {
        console.log(&#39;errParse: &#39;, errParse);
        return console.log(errParse);
      }
      return console.log(null, { books: resParse });
    });
  });
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 &lt;code&gt;npm install cheerio --save&lt;/code&gt;，将 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;password&lt;/code&gt; 改为正确的借阅证号和密码就可以登录成功，并获取到该用户的借阅列表了。&lt;/p&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node get_books.js
首页cookie:
  JSESSIONID=6EA8121AB1E4B3045A331198321F8ADC.irdmblhome72a; Path=/; HttpOnly,DSSTASH_LOG=C%5f4%2dUN%5f395%2dUS%5f%2d1%2dT%5f1475865139485; Domain=.5read.com; Path=/,mgid=274; Domain=.5read.com; Expires=Sun, 06-Nov-2016 18:32:19 GMT; Path=/,maid=395; Domain=.5read.com; Expires=Sun, 06-Nov-2016 18:32:19 GMT; Path=/,msign_dsr=1475865139507; Domain=.5read.com; Expires=Thu, 02-Oct-2036 18:32:19 GMT; Path=/,mduxiu=musername%2c%3dblmobile%2c%21muserid%2c%3d1000086%2c%21mcompcode%2c%3d1009%2c%21menc%2c%3d26A35FCD85F5A5677706DC7CE503113A; Domain=.5read.com; Expires=Sun, 06-Nov-2016 18:32:19 GMT; Path=/,xc=6; Domain=.5read.com; Expires=Sun, 06-Nov-2016 18:32:19 GMT; Path=/
登录成功后的 cookie:
  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
response.statusCode:  200

{ booksNumber: 2,
  books:
   [ { author: &#39;李刚&#39;,
       name: &#39;疯狂Swift讲义&#39;,
       expiredate: &#39;20161010&#39;,
       libraryBranch: &#39;JZLKS&#39;,
       number: &#39;TP312SW/4072&#39;,
       borId: &#39;U13014748&#39;,
       barCode: &#39;90577318&#39; },
     { author: &#39;杨宏焱&#39;,
       name: &#39;iOS 8 Swift编程指南&#39;,
       expiredate: &#39;20161010&#39;,
       libraryBranch: &#39;JZLKS&#39;,
       number: &#39;TP312SW/4739&#39;,
       borId: &#39;U13014748&#39;,
       barCode: &#39;90597040&#39; },
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到目前为止，模拟登录的程序就完成了，并且成功获取到了用户的借阅列表。&lt;/p&gt;

&lt;p&gt;由于很多很多大学的移动图书馆都使用同一个系统，所以这个程序具有通用性，所以本文的标题是《模拟登录某某大学图书馆系统》。&lt;/p&gt;

&lt;p&gt;不信你试试，说不定就有你的学校。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The innodb_system data file &#39;ibdata1&#39; must be writeable</title>
      <link>http://nodejh.com/postback/The-innodb_system-data-file-ibdata1-must-be-writeable/</link>
      <pubDate>Sun, 02 Oct 2016 00:53:28 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/The-innodb_system-data-file-ibdata1-must-be-writeable/</guid>
      <description>&lt;p&gt;今天重启电脑后 MySQL 又用不了了！&lt;/p&gt;

&lt;p&gt;然后查看了错误日志 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cat /usr/local/mysql/data/jh.local.err
2016-10-01T15:51:09.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data
2016-10-01T15:51:09.574413Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2016-10-01T15:51:09.574540Z 0 [Warning] &#39;NO_ZERO_DATE&#39;, &#39;NO_ZERO_IN_DATE&#39; and &#39;ERROR_FOR_DIVISION_BY_ZERO&#39; sql modes should be used with strict mode. They will be merged with strict mode in a future release.
2016-10-01T15:51:09.574546Z 0 [Warning] &#39;NO_AUTO_CREATE_USER&#39; sql mode was not set.
2016-10-01T15:51:09.574595Z 0 [Warning] Insecure configuration for --secure-file-priv: Current value does not restrict location of generated files. Consider setting it to a valid, non-empty path.
2016-10-01T15:51:09.574641Z 0 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.7.13) starting as process 7326 ...
2016-10-01T15:51:09.579265Z 0 [Warning] Setting lower_case_table_names=2 because file system for /usr/local/mysql/data/ is case insensitive
2016-10-01T15:51:09.581901Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins
2016-10-01T15:51:09.581934Z 0 [Note] InnoDB: Uses event mutexes
2016-10-01T15:51:09.581943Z 0 [Note] InnoDB: GCC builtin __atomic_thread_fence() is used for memory barrier
2016-10-01T15:51:09.581950Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.3
2016-10-01T15:51:09.582282Z 0 [Note] InnoDB: Number of pools: 1
2016-10-01T15:51:09.582394Z 0 [Note] InnoDB: Using CPU crc32 instructions
2016-10-01T15:51:09.583648Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M
2016-10-01T15:51:09.594097Z 0 [Note] InnoDB: Completed initialization of buffer pool
2016-10-01T15:51:09.606687Z 0 [ERROR] InnoDB: The innodb_system data file &#39;ibdata1&#39; must be writable
2016-10-01T15:51:09.606728Z 0 [ERROR] InnoDB: The innodb_system data file &#39;ibdata1&#39; must be writable
2016-10-01T15:51:09.606753Z 0 [ERROR] InnoDB: Plugin initialization aborted with error Generic error
2016-10-01T15:51:09.913995Z 0 [ERROR] Plugin &#39;InnoDB&#39; init function returned error.
2016-10-01T15:51:09.914027Z 0 [ERROR] Plugin &#39;InnoDB&#39; registration as a STORAGE ENGINE failed.
2016-10-01T15:51:09.914035Z 0 [ERROR] Failed to initialize plugins.
2016-10-01T15:51:09.914040Z 0 [ERROR] Aborting

2016-10-01T15:51:09.914056Z 0 [Note] Binlog end
2016-10-01T15:51:09.914142Z 0 [Note] Shutting down plugin &#39;CSV&#39;
2016-10-01T15:51:09.914491Z 0 [Note] /usr/local/mysql/bin/mysqld: Shutdown complete

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最关键的当然是 &lt;code&gt;2016-10-01T15:51:09.606687Z 0 [ERROR] InnoDB: The innodb_system data file &#39;ibdata1&#39; must be writable&lt;/code&gt;。说的是 &lt;code&gt;ibdata1&lt;/code&gt; 文件不可写。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ibdata1&lt;/code&gt; 是InnoDB的共有表空间，默认情况下会把表空间存放在一个文件ibdata1中，（此原因会造成这个文件越来越大）。&lt;/p&gt;

&lt;p&gt;所以大概能猜测是 mysql 用户的权限不够了。所以再给 &lt;code&gt;ibdata1&lt;/code&gt; 目录分配一下权限即可。&lt;/p&gt;

&lt;p&gt;这个时候需要查看一下mysql 安装目录权限。我没有查看，就直接使用 &lt;code&gt;chown&lt;/code&gt; 改变了整个 mysql 目录的权限，这是一个非常不好的习惯。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local/mysql
$ sudo chown -R _mysql:_mysql *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的是，macOS 系统下，mysql 的用户组和用户名都是 &lt;code&gt;_mysql&lt;/code&gt;，Linux 没记错的话应该是 &lt;code&gt;mysql&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后再重启 MySQL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mysql.server start
Password:
Starting MySQL
 SUCCESS!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题解决！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Hexo</title>
      <link>http://nodejh.com/postback/Migrate-to-Hugo-from-Hexo/</link>
      <pubDate>Fri, 30 Sep 2016 17:14:37 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Migrate-to-Hugo-from-Hexo/</guid>
      <description>

&lt;p&gt;把博客从 &lt;a href=&#34;http://hexo.io/&#34;&gt;Hexo&lt;/a&gt; 迁移到了 &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;。主要原因有二：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hexo 中文乱码。当中文大概超过1000字，就出现奇怪的乱码。看了 Hexo 的 ISSUE，这个问题也不只我遇到。&lt;/li&gt;
&lt;li&gt;Hexo 生成静态文件太慢了，等上十几二十秒是常有的事。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;遂弃用 Hexo。&lt;/p&gt;

&lt;h2 id=&#34;1-将-hexo-的-yaml-转换为-hugo-的-toml&#34;&gt;1. 将 Hexo 的 YAML 转换为 Hugo 的 TOML&lt;/h2&gt;

&lt;p&gt;Hugo 的配置文件是 TOML 格式的，其生成的 Markdown 文件的 front matter（不知如何翻译）也是 TOML 结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-09-30T17:14:37+08:00&amp;quot;
description = &amp;quot;&amp;quot;
title = &amp;quot;Migrate to Hugo from Hexo&amp;quot;
tags = [&amp;quot;hugo&amp;quot;, &amp;quot;hexo&amp;quot;, &amp;quot;blog&amp;quot;]

+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 Hexo 的配置文件是 YAML 格式，其 Markdown 文件的 front matter 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title: &#39;Start React with Webpack&#39;
date: 2016-09-09 04:11:13
tags:
  - webpack
  - react

---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以直接将 Hexo 的 Markdown 文件复制到 Hugo 中是不行的，必须得转换一下格式。虽然 Hugo 也可以直接在 &lt;code&gt;config.toml&lt;/code&gt; 中配置 &lt;code&gt;metaDataFormat:&amp;quot;yaml&amp;quot;&lt;/code&gt;，这样 Hugo 就会生成 YAML 结构的 front matter ，但原 Hexo 的 Markdown 文件依旧不能正常的转换，因为 &lt;code&gt;date&lt;/code&gt; 的格式不一样。&lt;/p&gt;

&lt;p&gt;在 Hexo 中，文件里面的 &lt;code&gt;date: 2016-09-09 04:11:13&lt;/code&gt; 并没有存储时区信息，而是把时区放在了 &lt;code&gt;_config.yml&lt;/code&gt; 配置文件中。&lt;/p&gt;

&lt;p&gt;By the way，TOML 是 GitHub 觉得 YAML 不够简洁优雅，所以捣鼓出来的一个东西。既然现在在用 Hugo，就没有理由不用 TOML 代替原来的 YAML。&lt;/p&gt;

&lt;p&gt;其实两者之间的转换也很简单，我用 JS 写了一个脚本来将 YAML 转换为 TOML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// yaml_to_toml.js
const readline = require(&#39;readline&#39;);
const fs = require(&#39;fs&#39;);
const os = require(&#39;os&#39;);
const moment = require(&#39;moment-timezone&#39;);  // 需要通过 npm install moment-timezone 来安装


const timezone = &#39;Asia/Shanghai&#39;;  // 时区
const src = &#39;hexo&#39;;  // hexo .md 文件源目录
const target = &#39;post&#39;;  // 目标文件目录


// 开始转换
readDir();


// 遍历目录
function readDir() {
    // read all files in src
    fs.readdir(src, function(err, files) {
        files.map((filename) =&amp;gt; {
            // get the file extension
            const extension = filename.substr(filename.lastIndexOf(&#39;.&#39;, filename.length));
            if (extension === &#39;.md&#39;) {
              readFile(`${filename}`);
            }
        });
    });

}


function readFile(filename) {
  fs.readFile(`${src}/${filename}`, { encoding: &#39;utf8&#39; }, function(err, data) {
      if (err) {
          return console.log(&#39;err: &#39;, err);
      }

      const content = data.split(&#39;---&#39;);
      const head = content[0].split(&#39;\n&#39;);
      // console.log(&#39;head: &#39;, head);

      let newHead = head.map((item, index) =&amp;gt; {
        // console.log(&#39;slpitHead: &#39;, slpitHead(item, index, head));
        return slpitHead(item, index, head);
      });
      newHead = newHead.filter((item) =&amp;gt; {return item;});
      // console.log(&#39;newHead: &#39;, newHead);
      const newContent = `+++${os.EOL}${newHead.join(os.EOL)}${os.EOL}${os.EOL}+++${os.EOL}${content[1]}`;
      fs.writeFile(`${target}/${filename}`, newContent, {
          encoding: &#39;utf8&#39;
      }, function(err) {
          if (err) {
            throw err;
          }
          console.log(`${filename}  生成成功！`);
      });
  });
}



function slpitHead(item, index, head) {
  // title
  if (item.indexOf(&#39;title:&#39;) !== -1) {
    return `title = &amp;quot;${item.split(&#39;title:&#39;)[1].trim()}&amp;quot;`;
  }

  // date
  if (item.indexOf(&#39;date:&#39;) !== -1) {
    return `date = &amp;quot;${(moment.tz(item.split(&#39;date:&#39;)[1], timezone)).format()}&amp;quot;`;
  }

  // tags
  if (item.indexOf(&#39;tags:&#39;) !== -1) {
    // console.log(&#39;tags...&#39;);
    const tags = [];
    for (let i=index+1; i&amp;lt;head.length; i++) {
      if (head[i].indexOf(&#39;-&#39;) !== -1) {
        // console.log(&#39;head[i].split(&#39;-&#39;)[1]: &#39;, head[i].split(&#39;-&#39;)[1]);
        tags.push(head[i].split(&#39;-&#39;)[1].trim());
      } else {
        break;
      }
    }
    // console.log(&#39;tags: &#39;, tags);
    return `tags = ${JSON.stringify(tags)}`;
  }

  // categories
  if (item.indexOf(&#39;categories:&#39;) !== -1) {
    const categories = [];
    for (let i=index+1; i&amp;lt;head.length; i++) {
      if (head[i].indexOf(&#39;-&#39;) !== -1) {
        categories.push(head[i].split(&#39;-&#39;)[1].trim());
      } else {
        break;
      }
    }
    // console.log(&#39;categories: &#39;, categories);
    return `categories = ${JSON.stringify(categories)}`;
  }

  return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先配置好 &lt;code&gt;timezone&lt;/code&gt; &lt;code&gt;src&lt;/code&gt; &lt;code&gt;target&lt;/code&gt; 三个参数。然后 &lt;code&gt;npm install moment-timezone&lt;/code&gt; 安装需要的第三方包，最后 &lt;code&gt;node yaml_to_toml.js&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h2 id=&#34;2-图片目录的迁移&#34;&gt;2. 图片目录的迁移&lt;/h2&gt;

&lt;p&gt;本地图片迁移也非常简单。&lt;/p&gt;

&lt;p&gt;我之前使用 Hexo 的时候，是将所有图片都放在 &lt;code&gt;source/images/&lt;/code&gt; 目录里面的，在 Markdown 文件中引入图片是这样的： &lt;code&gt;![image title](/iamges/image_name.png)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Hugo 的图片可以直接放在其 &lt;code&gt;static/&lt;/code&gt; 目录里面，其路径就是 &lt;code&gt;/iamges/image_name.png&lt;/code&gt;，所以我只需要将 Hexo 中的 &lt;code&gt;images&lt;/code&gt; 目录复制到 Hugo 的 &lt;code&gt;static/&lt;/code&gt; 目录下即可。&lt;/p&gt;

&lt;h2 id=&#34;3-主题&#34;&gt;3. 主题&lt;/h2&gt;

&lt;p&gt;看遍了 Hugo 给出的所有主题，都不满意。很多主题都超级简洁，这种风格还是很喜欢的。所以决定自己写一个。&lt;/p&gt;

&lt;p&gt;最终 Fork 了 &lt;a href=&#34;https://github.com/digitalcraftsman/hugo-cactus-theme&#34;&gt;https://github.com/digitalcraftsman/hugo-cactus-theme&lt;/a&gt; 这个主题，然后改成了自己想要的样子。&lt;/p&gt;

&lt;p&gt;主页&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-Migrate-to-Hugo-from-Hexo-1.png&#34; alt=&#34;Migrate-to-Hugo-from-Hexo-1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;文章页&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oh1ywjyqf.bkt.clouddn.com/blog/2016-11-22-Migrate-to-Hugo-from-Hexo-2.png&#34; alt=&#34;Migrate-to-Hugo-from-Hexo-2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;改后的主题源码：&lt;a href=&#34;https://github.com/nodejh/hugo-cactus-theme&#34;&gt;https://github.com/nodejh/hugo-cactus-theme&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;4-部署&#34;&gt;4. 部署&lt;/h2&gt;

&lt;p&gt;由于 Github Pages 国内访问速度慢，所以同时把静态页面部署到了 Github Page 和 Coding Pages。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 添加两个仓库
git remote add all https://github.com/nodejh/nodejh.github.io
git remote set-url origin --push --add https://git.coding.net/nodejh/nodejh.git
git remote set-url origin --push --add https://github.com/nodejh/nodejh.github.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后只需要执行 &lt;code&gt;git push all branch&lt;/code&gt; 就可以同时向两个仓库 push 代码了。但暂时不这样做。而是在 &lt;code&gt;public&lt;/code&gt; 目录外创建一个 &lt;code&gt;deploy.sh&lt;/code&gt; 目录，用来自动部署：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add -A

# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来再给 &lt;code&gt;deploy.sh&lt;/code&gt; 添加可执行权限 &lt;code&gt;chmod +x deploy.sh&lt;/code&gt;。然后每次写完东西只需要 &lt;code&gt;.／deploy.sh &#39;commit message&#39;&lt;/code&gt; 即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use eslint-config-airbnb in Atom</title>
      <link>http://nodejh.com/postback/use-eslint-config-airbnb-in-atom/</link>
      <pubDate>Tue, 27 Sep 2016 20:48:24 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/use-eslint-config-airbnb-in-atom/</guid>
      <description>

&lt;p&gt;ESlint 主要是用来帮助我们规范书写 JavaScript 代码。通过使用 Atom 的 ESLit 插件，并配合 Airbnb 的 ESLint 规则，我们可以一边编码一边检测语法。关于 ESLint 的详细介绍可看&lt;a href=&#34;http://eslint.org&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;1-在-atom-中安装-eslint&#34;&gt;1. 在 Atom 中安装 ESLint&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;apm install linter-eslint
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-在项目中使用-eslint-config-airbnb&#34;&gt;2. 在项目中使用 eslint-config-airbnb&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/eslint-config-airbnb#improving-this-config）是一个基于 [ Airbnb&#39;s Javascript styleguide](https://github.com/airbnb/javascript&#34;&gt;eslint-config-airbnb&lt;/a&gt; 的 ESLint 配置。安装方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save-dev eslint eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y eslint-config-airbnb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在项目根目录添加一个 &lt;code&gt;.eslintrc&lt;/code&gt; 文件，并在其中添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;extends&amp;quot;: &amp;quot;airbnb&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-自定义-eslint-规则&#34;&gt;3. 自定义 ESLint 规则&lt;/h4&gt;

&lt;p&gt;eslint-config-airbnb 中的规则，可能并不完全符合自己的编码习惯，我们还可以在 &lt;code&gt;.eslintrc&lt;/code&gt; 中添加一些自定义的规则。&lt;/p&gt;

&lt;h4 id=&#34;4-eslint-规则说明&#34;&gt;4. ESLint 规则说明&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;rules&amp;quot;: {

        /*Possible Errors*/

        // 数组和对象键值对最后一个逗号，

        // never参数：不能带末尾的逗号,

        // always参数：必须带末尾的逗号，  

        // always-multiline：多行模式必须带逗号，单行模式不能带逗号  

        &amp;quot;comma-dangle&amp;quot;: [2, &amp;quot;never&amp;quot;],

        //禁止在条件表达式中使用赋值语句

        &amp;quot;no-cond-assign&amp;quot;: 2,

        //禁止使用console

        &amp;quot;no-console&amp;quot;: 2,

        //禁止在条件中使用常量表达式 if(true) if(1)

        &amp;quot;no-constant-condition&amp;quot;: 2,

        //禁止在正则表达式中使用控制符

        &amp;quot;no-control-regex&amp;quot;: 2,

        //禁止使用debugger语句

        &amp;quot;no-debugger&amp;quot;: 2,

        //函数参数禁止重名

        &amp;quot;no-dupe-args&amp;quot;: 2,

        //在创建对象字面量时不允许键重复

        &amp;quot;no-dupe-keys&amp;quot;: 2,

        //在switch语句中禁止重复的case

        &amp;quot;no-duplicate-case&amp;quot;: 2,

        //代码块的内容不能为空，禁止空代码块

        &amp;quot;no-empty&amp;quot;: 2,

        //正则表达式的内容不能为空，禁止使用不匹配任何字符串的正则表达式

        &amp;quot;no-empty-character-class&amp;quot;: 2,

        //禁止对catch语句中的异常进行赋值

        &amp;quot;no-ex-assign&amp;quot;: 2,

        //禁止不必要的bool转换

        &amp;quot;no-extra-boolean-cast&amp;quot;: 2,

        //禁止使用多余的圆括号

        &amp;quot;no-extra-parens&amp;quot;: 2,

        //禁止多余的冒号

        &amp;quot;no-extra-semi&amp;quot;: 2,

        //禁止重复的函数声明

        &amp;quot;no-func-assign&amp;quot;: 2,

        //禁止在块语句中声明变量或函数

        &amp;quot;no-inner-declarations&amp;quot;: 2,

        //禁止使用无效的正则语句

        &amp;quot;no-invalid-regexp&amp;quot;: 2,

        //禁止使用不合法或者不规则的空白符

        &amp;quot;no-irregular-whitespace&amp;quot;: 2,

        //在in操作符左边的操作项不能用! 例如这样写不对的：if ( !a in b) { //dosomething }

        &amp;quot;no-negated-in-lhs&amp;quot;: 2,

        //禁止把全局对象当函数调用，比如下面写法错误的：Math(), JSON()

        &amp;quot;no-obj-calls&amp;quot;: 2,

        //禁止在正则表达式字面量中使用多个空格 /foo bar/

        &amp;quot;no-regex-spaces&amp;quot;: 2,

        //禁止稀疏数组，清除多余的逗号申明  比如[1,,2]

        &amp;quot;no-sparse-arrays&amp;quot;: 2,

        //为了保证两行不相关的代码不会意外的被当做一行代码来解析

        &amp;quot;no-unexpected-multiline&amp;quot;: 2,

        //禁止有执行不到的代码

        &amp;quot;no-unreachable&amp;quot;: 2,

        //禁止和NaN作比较,推荐使用isNaN方法

        &amp;quot;use-isnan&amp;quot;: 2,

        //用来检测JSDoc是否完整和合法

        &amp;quot;valid-jsdoc&amp;quot;: 2,

        //typeof操作符返回的结果会是 &amp;quot;undefined&amp;quot;,  &amp;quot;object&amp;quot;,  &amp;quot;boolean&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;string&amp;quot;, 和  &amp;quot;function&amp;quot;之一。

        //保证typeof 操作符返回的结果必须和上面六个字符串作比较

        &amp;quot;valid-typeof&amp;quot;: 2,



        /*Best Practices*/

        //在声明对象时getter和setter需成对出现

        &amp;quot;accessor-pairs&amp;quot;: 2,

        //数值方法的回调函数中强制写return语句

        &amp;quot;array-callback-return&amp;quot;: 2,

        //当在代码块中用var声明变量，并在代码块外使用时报错

        &amp;quot;block-scoped-var&amp;quot;: 0,

        //用来控制函数的复杂度，分支超过5时报错

        &amp;quot;complexity&amp;quot;: [2, 5],

        //不同分支的return语句不能返回不同的类型，要么一致要么都没有  

        &amp;quot;consistent-return&amp;quot;: 0,

        // if else while for do后面的代码块是否需要{ }包围，参数：  

        // multi         只有块中有多行语句时才需要{ }包围  

        // multi-line    只有块中有多行语句时才需要{ }包围, 但是块中的执行语句只有一行时，块中的语句只能跟和if语句在同一行。

        //                if (foo) foo++; else doSomething();  

        // multi-or-nest 只有块中有多行语句时才需要{ }包围, 如果块中的执行语句只有一行，执行语句可以另起一行也可以跟在if语句后面    

        // [2, &amp;quot;multi&amp;quot;, &amp;quot;consistent&amp;quot;] 保持前后语句的{ }一致  

        // default: [2, &amp;quot;all&amp;quot;] 全都需要{ }包围  

        &amp;quot;curly&amp;quot;: 2,

        //所有的switch语句都必须要有一个default分支

        &amp;quot;default-case&amp;quot;: 2,

        // 在书写对象的属性或方法时，新的一行代码可以以. 开头，也可以以. 结束。

        // 强制统一object.key中 . 的位置，参数:  

        //      property，&#39;.&#39;号应与属性在同一行  

        //      object, &#39;.&#39; 号应与对象名在同一行  

        &amp;quot;dot-location&amp;quot;: [2, &amp;quot;property&amp;quot;],

        // 强制使用.号取属性  

        // 参数： allowKeywords：true  使用保留字做属性名时，只能使用.方式取属性  

        //                       false 使用保留字做属性名时, 只能使用[]方式取属性

        //                       e.g [2, {&amp;quot;allowKeywords&amp;quot;: false}]  

        //        allowPattern:  当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值

        //                       e.g [2, {&amp;quot;allowPattern&amp;quot;: &amp;quot;^[a-z]+(_[a-z]+)+$&amp;quot;}]  

        &amp;quot;dot-notation&amp;quot;: [2, { &amp;quot;allowKeywords&amp;quot;: true }],

        //在进行比较时，必须使用全等=== 和完全不等!==

        &amp;quot;eqeqeq&amp;quot;: [2, &amp;quot;allow-null&amp;quot;],

        //在for-in 循环中要使用if语句

        &amp;quot;guard-for-in&amp;quot;: 2,

        //代码中禁止使用alert, confirm, and prompt

        &amp;quot;no-alert&amp;quot;: 2,

        //禁止使用arguments.caller和arguments.callee

        &amp;quot;no-caller&amp;quot;: 2,

        //禁止在case/default语句中使用lexical declarations，例如let, const, function and class

        //因为在case/default中的声明，在整个switch语句中都能够访问到，如果需要声明变量，可以加大括号。

        &amp;quot;no-case-declarations&amp;quot;: 2,

        //不能使用看起来像除法的正则表达式

        //用来消除/ (除号)操作符对程序员的迷惑，比如在正则表达式/=foo/中，我们并不能够确定第一个/是除号还是正则表达式，因此我们需要在等号前面加一个转移符/\=foo/

        &amp;quot;no-div-regex&amp;quot;: 2,

        //在if else语句中，如果else语句中只含有一个return语句，那么完全可以不使用else语句，直接return。

        &amp;quot;no-else-return&amp;quot;: 2,

        //不允许空函数

        &amp;quot;no-empty-function&amp;quot;: 2,

        //在结构赋值时，模式不能为空。在ECMAScript2015的结构赋值中，模式为空是不会报错的，只是这样的结构赋值没有任何效果，该条规则就保证了模式不能为空，也就保证了结构赋值的有效性。

        &amp;quot;no-empty-pattern&amp;quot;: 2,

        //保证了在和null比较时使用===和!==，而不能够使用==和!=

        &amp;quot;no-eq-null&amp;quot;: 2,

        //禁止使用eval函数

        &amp;quot;no-eval&amp;quot;: 2,

        //禁止扩展native对象，不能向native的对象上面添加属性

        &amp;quot;no-extend-native&amp;quot;: 2,

        //保证了调用bind方法的函数体内有this对象。规避了不必要的使用bind方法的情况。

        //箭头函数中没有this对象，也就不能够使用bind()方法。该规则保证了在所有的箭头函数中使用bind方法将被视为错误。

        &amp;quot;no-extra-bind&amp;quot;: 2,

        //如果 loop中没有内嵌的loops或switches, loop标签是不必要的.

        &amp;quot;no-extra-label&amp;quot;: 2,

        //在case语句中尽量加break，避免不必要的fallthrough错误，消除从一个case到另一个case的非故意的「fall through」。

        //如果没有添加break等终止语句或者没有添加注释语句，将会抛出错误

        &amp;quot;no-fallthrough&amp;quot;: 2,

        //在使用浮点小数时，不能够省略小数点前面的数或者后面的数，必须写。比如.2 2. 应该写2.2 2.0

        &amp;quot;no-floating-decimal&amp;quot;: 2,

        //禁止隐式转换，为了消除简写的类型转换

        &amp;quot;no-implicit-coercion&amp;quot;: 2,

        //禁止在全局作用域里声明变量或函数

        &amp;quot;no-implicit-globals&amp;quot;: 2,

        //在setTimeout(), setInterval() or execScript()中消除隐式eval的使用

        &amp;quot;no-implied-eval&amp;quot;: 2,

        //禁止无效的this，只能用在构造器，类，对象字面量

        &amp;quot;no-invalid-this&amp;quot;: 2,

        //禁止使用__iterator__属性

        &amp;quot;no-iterator&amp;quot;: 2,

        //禁止使用label语句，以避免无限循环

        &amp;quot;no-labels&amp;quot;: [2, { &amp;quot;allowLoop&amp;quot;: false, &amp;quot;allowSwitch&amp;quot;: false }],

        //禁止使用不必要的嵌套代码块

        &amp;quot;no-lone-blocks&amp;quot;: 2,

        //禁止在循环体中定义函数并且函数引用了外部变量

        //在循环中定义了函数，但是函数内部没有引用外部变量，或者使用let定义的代码块变量，视为合法

        &amp;quot;no-loop-func&amp;quot;: 2,

        //禁止使用魔法数字，建议使用常量来代替

        &amp;quot;no-magic-numbers&amp;quot;: 2,

        //保证了在逻辑表达式、条件表达式、申明语句、数组元素、对象属性、sequences、函数参数中不使用超过一个的空白符。

        &amp;quot;no-multi-spaces&amp;quot;: 2,

        //该规则保证了字符串不分行书写。

        &amp;quot;no-multi-str&amp;quot;: 2,

        //该规则保证了不重写原生对象。

        &amp;quot;no-native-reassign&amp;quot;: 2,

        //在使用new来调用构造函数后，必须把生成的实例赋值给一个变量

        &amp;quot;no-new&amp;quot;: 2,

        //禁止使用new Function(); 语句。

        &amp;quot;no-new-func&amp;quot;: 2,

        //禁止使用new创建String,Number, and Boolean实例

        &amp;quot;no-new-wrappers&amp;quot;: 2,

        //禁止使用八进制数字

        &amp;quot;no-octal&amp;quot;: 2,

        //禁止使用八进制转义序列，比如 var foo = &amp;quot;Copyright \251&amp;quot;;

        &amp;quot;no-octal-escape&amp;quot;: 2,

        //禁止对函数的参数重新进行无意义的赋值

        &amp;quot;no-param-reassign&amp;quot;: 2,

        //禁止使用__proto__属性

        &amp;quot;no-proto&amp;quot;: 2,

        //避免重复声明一个变量

        &amp;quot;no-redeclare&amp;quot;: [2, { &amp;quot;builtinGlobals&amp;quot;: true }],

        //不要在return语句中使用赋值语句

        &amp;quot;no-return-assign&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //禁止代码中使用类似javascript:void(0)的javascript: urls.

        &amp;quot;no-script-url&amp;quot;: 2,

        //禁止给自身赋值

        &amp;quot;no-self-assign&amp;quot;: 2,

        //禁止和自身作比较

        &amp;quot;no-self-compare&amp;quot;: 2,

        //禁止可能导致结果不明确的逗号操作符

        &amp;quot;no-sequences&amp;quot;: 2,

        //通过throw语句抛出的对象必须是Error对象本身或者通过Error对象定义的对象。有些情况除外，见官网

        &amp;quot;no-throw-literal&amp;quot;: 2,

        //禁止使用不被修改的循环条件

        &amp;quot;no-unmodified-loop-condition&amp;quot;: 2,

        //禁止在代码中出现没有被使用到的表达式或值

        &amp;quot;no-unused-expressions&amp;quot;: [2, { &amp;quot;allowShortCircuit&amp;quot;: true, &amp;quot;allowTernary&amp;quot;: true }],

        //禁止在代码中出现没有被使用到的标签

        &amp;quot;no-unused-labels&amp;quot;: 2,

        //避免使用没有意义的call() 和 apply()

        &amp;quot;no-useless-call&amp;quot;: 2,

        //避免使用不必要的字符串拼接

        &amp;quot;no-useless-concat&amp;quot;: 2,

        //不要使用void操作符

        &amp;quot;no-void&amp;quot;: 2,

        //生产代码中不能出现warning-comments包含的注释

        &amp;quot;no-warning-comments&amp;quot;: [2, { &amp;quot;terms&amp;quot;: [&amp;quot;todo&amp;quot;, &amp;quot;fixme&amp;quot;, &amp;quot;any other term&amp;quot;], &amp;quot;location&amp;quot;: &amp;quot;anywhere&amp;quot; }],

        //不要使用with语句

        &amp;quot;no-with&amp;quot;: 2,

        //在使用parseInt()方法时，必须要传递第二个参数来帮助解析。

        &amp;quot;radix&amp;quot;: 2,

        //在通过var声明变量时，应该放在代码所在作用域的顶部

        &amp;quot;vars-on-top&amp;quot;: 2,

        //立即执行函数需要通过圆括号包围

        &amp;quot;wrap-iife&amp;quot;: 2,

        //yoda条件语句就是对象字面量应该写在比较操作符的左边，而变量应该写在比较操作符的右边

        //默认的规则要求，变量写在左边而字面量写在右边

        &amp;quot;yoda&amp;quot;: 2,



        /*Strict Mode*/

        //使用严格模式

        &amp;quot;strict&amp;quot;: 2,





        /*Variables*/

        //变量声明时必须赋初值

        &amp;quot;init-declarations&amp;quot;: 2,

        //In IE 8 and earlier，禁止catch子句参数与外部作用域变量同名

        &amp;quot;no-catch-shadow&amp;quot;: 2,

        //禁止使用delete删除var声明的变量

        &amp;quot;no-delete-var&amp;quot;: 2,

        //防止label和声明的变量重名

        &amp;quot;no-label-var&amp;quot;: 2,

        //禁止使用某些全局变量

        &amp;quot;no-restricted-globals&amp;quot;: [2, &amp;quot;event&amp;quot;],

        //禁止声明外部作用域中已定义的变量

        &amp;quot;no-shadow&amp;quot;: 2,

        //声明变量时禁止覆盖JavaScript中的一些保留关键字，比如NaN、Infinity、undefined、eval、arguments等。

        &amp;quot;no-shadow-restricted-names&amp;quot;: 2,

        //禁止使用未被定义的变量，除非已在配置文件的global中进行了说明。

        &amp;quot;no-undef&amp;quot;: 2,

        //禁止初始化变量为undefined

        &amp;quot;no-undef-init&amp;quot;: 2,

        //禁止把undefined作为变量名

        &amp;quot;no-undefined&amp;quot;: 2,

        //不允许定义的变量在后面的代码中没有被使用到

        &amp;quot;no-unused-vars&amp;quot;: 2,

        //所有的变量都应该先定义后使用

        &amp;quot;no-use-before-define&amp;quot;: 2,







        /*Node.js and CommonJS*/

        //强制回调后return，避免多次调用回调

        &amp;quot;callback-return&amp;quot;: 2,

        //强制require()出现在模块作用域的顶部

        &amp;quot;global-require&amp;quot;: 2,

        // 如果函数有err入参(err或者error),在函数体内必须进行处理

        &amp;quot;handle-callback-err&amp;quot;: [2, &amp;quot;^(err|error)$&amp;quot;],

        //声明时不能混用声明类型

        &amp;quot;no-mixed-requires&amp;quot;: 2,

        //禁止把require方法和new操作符一起使用。

        &amp;quot;no-new-require&amp;quot;: 2,

        //不能使用__dirname或__filename做路径拼接

        &amp;quot;no-path-concat&amp;quot;: 2,

        //禁止使用process.env

        &amp;quot;no-process-env&amp;quot;: 2,

        //禁止使用process.exit()

        &amp;quot;no-process-exit&amp;quot;: 2,

        //禁用使用指定模块，使用了就会报错

        &amp;quot;no-restricted-modules&amp;quot;: [2, &amp;quot;fs&amp;quot;],

        //禁止使用同步方法，建议使用异步方法

        &amp;quot;no-sync&amp;quot;: 2,





        /*Stylistic Issues*/

        // 用数组字面量定义数组时数组元素前后是否加空格，

        // never参数： 数组元素前后不能带空格，

        // always参数：数组元素前后必须留空格  

        &amp;quot;array-bracket-spacing&amp;quot;: [2, &amp;quot;never&amp;quot;],

        //在单行代码块中，代码块前后是否需要留空格

        // always参数：默认，前后必须留空格

        // never参数： 前后不能带空格  

        &amp;quot;block-spacing&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //大括号的样式，比如下面的大括号语法采用『1tbs』,允许单行样式

        &amp;quot;brace-style&amp;quot;: [2, &amp;quot;1tbs&amp;quot;, { &amp;quot;allowSingleLine&amp;quot;: true }],

        //强制使用驼峰命名  

        &amp;quot;camelcase&amp;quot;: 2,

        //规定了逗号前后的空白，默认配置规定逗号前面没有空白，而逗号后面需要留空白

        &amp;quot;comma-spacing&amp;quot;: [2, { &amp;quot;before&amp;quot;: false, &amp;quot;after&amp;quot;: true }],

        //规定了逗号放的位置，默认配置逗号应该放在行末，如果设置为first，逗号就应放在行首

        &amp;quot;comma-style&amp;quot;: [2, &amp;quot;last&amp;quot;],

        //是否在对象的动态属性（computed properties： ES6引入）中添加空白，默认配置不添加空白

        &amp;quot;computed-property-spacing&amp;quot;: [2, &amp;quot;never&amp;quot;],

        //统一this的别名（this赋值的变量名）保证整个应用程序代码的统一。

        //如果一个变量被指定为this对象的别名，那么这个变量就不能够用来赋其他值，只能够用来保存this对象。

        //如果this对象明确被赋值给了一个变量，那么这个变量应该是配置中指定的那个变量名。     

        &amp;quot;consistent-this&amp;quot;: [2, &amp;quot;self&amp;quot;],

        //该规则规定文件最后强制换行，仅需留一空行

        &amp;quot;eol-last&amp;quot;: 2,

        //要求给函数表达式命名，便于debug

        &amp;quot;func-names&amp;quot;: 2,

        //在JavaScript中有两种方式定义函数:函数声明和函数表达式。

        //函数声明就是把function关键词写在最前面，后面跟一个函数名。我们可以在函数申明代码前调用函数

        //函数表达式是通过var等声明变量的关键字开头，然后跟函数名，再后面是function本身。在使用函数表达式定义函数前调用函数会报错

        // 统一定义函数是所采用的方式，参数：  

        //    declaration: 强制使用方法声明的方式，function f(){} e.g [2, &amp;quot;declaration&amp;quot;]  

        //    expression：强制使用方法表达式的方式，默认方式，var f = function() {}  e.g [2, &amp;quot;expression&amp;quot;]  

        //    allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &amp;quot;declaration&amp;quot;, {&amp;quot;allowArrowFunctions&amp;quot;:true}]  

        &amp;quot;func-style&amp;quot;: [2, &amp;quot;expression&amp;quot;],

        //规定了标识符命名的黑名单

        &amp;quot;id-blacklist&amp;quot;: [2, &amp;quot;data&amp;quot;, &amp;quot;err&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;cb&amp;quot;, &amp;quot;callback&amp;quot;],

        //规定标识符的长度，默认配置标识符最少两个字符

        &amp;quot;id-length&amp;quot;: [2, { &amp;quot;min&amp;quot;: 2 }],

        //命名检测，标识符命名需和配置中的正则表达式匹配，但是该规则对函数调用无效。

        &amp;quot;id-match&amp;quot;: [2, &amp;quot;^[a-z]+([A-Z][a-z]+)*$&amp;quot;, { &amp;quot;properties&amp;quot;: false }],

        // 统一代码缩进方式，默认值是4 spaces.

        &amp;quot;indent&amp;quot;: 2,

        //规定了在JSX中的属性值是使用单引号还是双引号,默认使用双引号

        &amp;quot;jsx-quotes&amp;quot;: [2, &amp;quot;prefer-double&amp;quot;],

        //该规则规定了在对象字面量语法中key和value之间的空白，冒号前不要留空格，冒号后面需留一个空格

        &amp;quot;key-spacing&amp;quot;: [2, { &amp;quot;beforeColon&amp;quot;: false, &amp;quot;afterColon&amp;quot;: true }],

        // 规定了keyword前后是否需要留一个空格

        &amp;quot;keyword-spacing&amp;quot;: [2, { &amp;quot;before&amp;quot;: true, &amp;quot;after&amp;quot;: true, &amp;quot;overrides&amp;quot;: {} }],

        //统一换行符，&amp;quot;\n&amp;quot; unix(for LF) and &amp;quot;\r\n&amp;quot; for windows(CRLF)，默认unix

        &amp;quot;linebreak-style&amp;quot;: 2,

        //规定注释和代码块之间是否留空行

        &amp;quot;lines-around-comment&amp;quot;: 2,

        //规定代码最多可以嵌套多少层

        &amp;quot;max-depth&amp;quot;: [2, 4],

        //规定了代码单行的最大长度

        &amp;quot;max-len&amp;quot;: [2, 80, 4],

        //规定了回调的最大嵌套层数

        &amp;quot;max-nested-callbacks&amp;quot;: [2, 10],

        //规定了函数参数的最大个数

        &amp;quot;max-params&amp;quot;: [2, 3],

        //规定了函数中代码不能够超过多少行

        &amp;quot;max-statements&amp;quot;: [2, 10],

        //使用构造函数(new)时首字母需大写，首字母大写的函数需用new操作符

        &amp;quot;new-cap&amp;quot;: 2,

        //使用构造函数(new)时必须圆括号不能省略

        &amp;quot;new-parens&amp;quot;: 2,

        //规定了变量声明后是否需要空行

        &amp;quot;newline-after-var&amp;quot;: 2,

        //规定了return语句前是否是否需要空行

        &amp;quot;newline-before-return&amp;quot;: 2,

        //规定了方法链式调用时是否需换行

        &amp;quot;newline-per-chained-call&amp;quot;: 2,

        //禁止使用Array构造函数

        &amp;quot;no-array-constructor&amp;quot;: 2,

        //禁止使用位操作符

        &amp;quot;no-bitwise&amp;quot;: 2,

        //禁止使用continue

        &amp;quot;no-continue&amp;quot;: 2,

        //禁止使用行内注释

        &amp;quot;no-inline-comments&amp;quot;: 2,

        //禁止在if-else控制语句中，else代码块中仅包含一个if语句

        &amp;quot;no-lonely-if&amp;quot;: 2,

        //禁止混用tab和空格

        &amp;quot;no-mixed-spaces-and-tabs&amp;quot;: 2,

        //不要留超过规定数目的空白行

        &amp;quot;no-multiple-empty-lines&amp;quot;: [2, { &amp;quot;max&amp;quot;: 2 }],

        //在if语句中使用了否定表达式，同时else语句又不为空，那么这样的if-else语句将被视为不合法，为什么不将其反过来这样代码更容易理解，该规则同样适用于三元操作符

        &amp;quot;no-negated-condition&amp;quot;: 2,

        //三元操作符禁止嵌套

        &amp;quot;no-nested-ternary&amp;quot;: 2,

        //禁止使用new Object()来构造对象

        &amp;quot;no-new-object&amp;quot;: 2,

        //禁止使用++，--

        &amp;quot;no-plusplus&amp;quot;: 2,

        //禁止使用某些特定的JavaScript语法，例如FunctionDeclaration 和 WithStatement

        &amp;quot;no-restricted-syntax&amp;quot;: [2, &amp;quot;FunctionExpression&amp;quot;, &amp;quot;WithStatement&amp;quot;],

        //函数调用时，函数名和圆括号之间不能有空格

        &amp;quot;no-spaced-func&amp;quot;: 2,

        //禁止使用三元操作符

        &amp;quot;no-ternary&amp;quot;: 2,

        //禁止行末加空格

        &amp;quot;no-trailing-spaces&amp;quot;: 2,

        //禁止在标识符前后使用下划线

        &amp;quot;no-underscore-dangle&amp;quot;: 2,

        //禁止使用没有必要的三元操作符，因为用有些三元操作符可以使用其他语句替换

        &amp;quot;no-unneeded-ternary&amp;quot;: [2, { &amp;quot;defaultAssignment&amp;quot;: false }],

        //禁止属性操作符.的前后和[之前有空格

        &amp;quot;no-whitespace-before-property&amp;quot;: 2,

        //规定对象字面量中大括号内是否允许加空格，也适用于ES6中的结构赋值和模块import和export

        &amp;quot;object-curly-spacing&amp;quot;: [2, &amp;quot;never&amp;quot;],

        //规定了在每个函数中声明变量是否只使用一次var，该规则同样适用于let和const

        &amp;quot;one-var&amp;quot;: [2, { &amp;quot;initialized&amp;quot;: &amp;quot;never&amp;quot; }],

        //规定了使用赋值操作符的简写形式

        &amp;quot;operator-assignment&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //在换行时操作符应该放在行首还是行尾。还可对某些操作符进行重写。

        &amp;quot;operator-linebreak&amp;quot;: [2, &amp;quot;after&amp;quot;, { &amp;quot;overrides&amp;quot;: { &amp;quot;?&amp;quot;: &amp;quot;before&amp;quot;, &amp;quot;:&amp;quot;: &amp;quot;before&amp;quot; } }],

        //在代码块中，代码块的开始和结尾是否应该留一个空行

        &amp;quot;padded-blocks&amp;quot;: 0,

        //对象的属性名是否强制加双引号

        &amp;quot;quote-props&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //在JavaScript中有三种方式定义字符串，双引号、单引号、反义符（ECMAScript2015）。规定了字符串定义的方式

        &amp;quot;quotes&amp;quot;: [2, &amp;quot;single&amp;quot;, &amp;quot;avoid-escape&amp;quot;],

        //注释格式要求JSDoc格式

        &amp;quot;require-jsdoc&amp;quot;: [2, {

            &amp;quot;require&amp;quot;: {

                &amp;quot;FunctionDeclaration&amp;quot;: true,

                &amp;quot;MethodDefinition&amp;quot;: false,

                &amp;quot;ClassDeclaration&amp;quot;: false

            }

        }],

        //JavaScript不要求在每行末尾加上分号，这是因为JavaScript引擎会决定是否需要在行末加上分号，然后自动帮我们在行末加上分号，这一特性被成为ASI(automatic semicolon insertion)，也是JavaScript语言最富争议的特性之一

        //尽管ASI允许我们使用更加自由的代码风格，但是它也可能使得你的代码并不是按你期许的方式运行

        //两个可选参数，always 和never

        //默认配置always，要求在行末加上分号。

        &amp;quot;semi&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //该规则用来规定分号前后是否加空格，默认配置如下

        &amp;quot;semi-spacing&amp;quot;: [2, { &amp;quot;before&amp;quot;: false, &amp;quot;after&amp;quot;: true }],

        //要求对同一个模块里的import声明按字母排序

        &amp;quot;sort-imports&amp;quot;: 2,

        //规定在同一个变量声明代码块中，要对变量的声明按字母排序

        &amp;quot;sort-vars&amp;quot;: 2,

        //规定了在代码块前是否需要加空格

        &amp;quot;space-before-blocks&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //函数定义时，function关键字后面的小括号前是否需要加空格

        &amp;quot;space-before-function-paren&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //规定圆括号内部的空格。规定是否需要在(右边，或者)左边加空格。

        &amp;quot;space-in-parens&amp;quot;: [2, &amp;quot;never&amp;quot;],

        //中綴操作符左右是否添加空格

        &amp;quot;space-infix-ops&amp;quot;: 2,

        //规定在一元操作符前后是否需要加空格，单词类操作符需要加，而非单词类操作符不用加

        //words - applies to unary word operators such as: new, delete, typeof, void, yield

        //nonwords - applies to unary operators such as: -, +, --, ++, !, !!

        &amp;quot;space-unary-ops&amp;quot;: [2, { &amp;quot;words&amp;quot;: true, &amp;quot;nonwords&amp;quot;: false }],

        //规定是否需要在代码注释起始符// or /*后面至少紧跟一个空格

        &amp;quot;spaced-comment&amp;quot;: [2, &amp;quot;always&amp;quot;, { &amp;quot;markers&amp;quot;: [&amp;quot;global&amp;quot;, &amp;quot;globals&amp;quot;, &amp;quot;eslint&amp;quot;, &amp;quot;eslint-disable&amp;quot;, &amp;quot;*package&amp;quot;, &amp;quot;!&amp;quot;, &amp;quot;,&amp;quot;] }],

        //要求在正则表达式的双斜杠外面加一个圆括号，来消除歧义

        &amp;quot;wrap-regex&amp;quot;: 2,





        /*ECMAScript 6*/

        //箭头函数中，如果函数体里只有一句代码时可以省略大括号

        //规定是否可以省略大括号

        &amp;quot;arrow-body-style&amp;quot;: 2,

        //箭头函数中，只有一个参数时可以省略圆括号

        //规定了参数是否需要圆括号包围

        &amp;quot;arrow-parens&amp;quot;: [2, &amp;quot;always&amp;quot;],

        //规定了箭头函数的箭头前后是否加空格

        &amp;quot;arrow-spacing&amp;quot;: [2, { &amp;quot;before&amp;quot;: true, &amp;quot;after&amp;quot;: true }],

        //保证constructor函数中super()应正确出现，比如在继承的classes中（派生类）必须使用super，否则（非派生类）不要使用super。

        &amp;quot;constructor-super&amp;quot;: 2,

        //规定generator函数中星号前后的空白

        &amp;quot;generator-star-spacing&amp;quot;: [2, { &amp;quot;before&amp;quot;: true, &amp;quot;after&amp;quot;: true }],

        //禁止覆盖class命名，也就是说变量名不要和class名重名

        &amp;quot;no-class-assign&amp;quot;: 2,

        //箭头函数的箭头和比较操作符 (&amp;gt;, &amp;lt;, &amp;lt;=, and &amp;gt;=)很相似，该规则要求在和比较操作符容易发生混淆时禁止使用箭头函数语法

        &amp;quot;no-confusing-arrow&amp;quot;: 2,

        //禁止修改const声明的变量

        &amp;quot;no-const-assign&amp;quot;: 2,

        //class中的成员不允许有相同的名字

        &amp;quot;no-dupe-class-members&amp;quot;: 2,

        //禁止在Symbol对象前使用new操作符

        &amp;quot;no-new-symbol&amp;quot;: 2,

        //该规则可以定义不允许在应用中导入的模块

        &amp;quot;no-restricted-imports&amp;quot;: [2,

            &amp;quot;assert&amp;quot;, &amp;quot;buffer&amp;quot;, &amp;quot;child_process&amp;quot;, &amp;quot;cluster&amp;quot;, &amp;quot;crypto&amp;quot;, &amp;quot;dgram&amp;quot;, &amp;quot;dns&amp;quot;, &amp;quot;domain&amp;quot;, &amp;quot;events&amp;quot;, &amp;quot;freelist&amp;quot;, &amp;quot;fs&amp;quot;, &amp;quot;http&amp;quot;, &amp;quot;https&amp;quot;, &amp;quot;module&amp;quot;, &amp;quot;net&amp;quot;, &amp;quot;os&amp;quot;, &amp;quot;path&amp;quot;, &amp;quot;punycode&amp;quot;, &amp;quot;querystring&amp;quot;, &amp;quot;readline&amp;quot;, &amp;quot;repl&amp;quot;, &amp;quot;smalloc&amp;quot;, &amp;quot;stream&amp;quot;, &amp;quot;string_decoder&amp;quot;, &amp;quot;sys&amp;quot;, &amp;quot;timers&amp;quot;, &amp;quot;tls&amp;quot;, &amp;quot;tracing&amp;quot;, &amp;quot;tty&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;util&amp;quot;, &amp;quot;vm&amp;quot;, &amp;quot;zlib&amp;quot;

        ],

        //在构造函数中，禁止在super()调用前使用this/super对象

        &amp;quot;no-this-before-super&amp;quot;: 2,

        //ES2015提供了默认的空构造函数，禁止使用不必要的空构造函数

        &amp;quot;no-useless-constructor&amp;quot;: 2,

        //禁用var，用let和const代替var

        &amp;quot;no-var&amp;quot;: 2,

        //ES6中提供了定义对象字面量的方法和属性的简写形式。强制要求在对象字面量中使用方法和属性的简写形式

        &amp;quot;object-shorthand&amp;quot;: 2,

        //函数作为函数的参数传入时，传入的函数需要是箭头函数

        //箭头函数中的this对象直接绑定到了其外面包围的函数的this对象。

        &amp;quot;prefer-arrow-callback&amp;quot;: 2,

        //如果一个变量声明后不再被修改，那么应使用const来声明该变量

        &amp;quot;prefer-const&amp;quot;: 2,

        //推荐使用Reflect上的方法替代以前老方法

        &amp;quot;prefer-reflect&amp;quot;: 2,

        // 在ES2015(ES6)中推荐使用剩余参数(...rest)代替arguments变量

        &amp;quot;prefer-rest-params&amp;quot;: 2,

        //在ES2015(ES6)中推荐使用扩展符替代apply()方法

        &amp;quot;prefer-spread&amp;quot;: 2,

        //在ES2015(ES6)中推荐使用模板代替以前的字符串拼接

        &amp;quot;prefer-template &amp;quot;: 2,

        //生成器函数中必须有yield关键字，如果没有会报错。

        &amp;quot;require-yield&amp;quot;: 2,

        //模板字符串中使用${ 和 } 包含的表达式前后是否需要留空格，默认规则禁止花括号内有空格

        &amp;quot;template-curly-spacing&amp;quot;: [2, &amp;quot;never&amp;quot;],

        //yield*表达式中的*号前后是否留空格，默认after，比如yield* other()

        &amp;quot;yield-star-spacing&amp;quot;: [2, &amp;quot;after&amp;quot;],









        /*eslint-plugin-standard*/

        &amp;quot;standard/object-curly-even-spacing&amp;quot;: [2, &amp;quot;either&amp;quot;],

        &amp;quot;standard/array-bracket-even-spacing&amp;quot;: [2, &amp;quot;either&amp;quot;],

        &amp;quot;standard/computed-property-even-spacing&amp;quot;: [2, &amp;quot;even&amp;quot;],





        /* eslint-plugin-promise*/

        &amp;quot;promise/param-names&amp;quot;: 2,

        &amp;quot;promise/always-return&amp;quot;: 2,

        &amp;quot;promise/catch-or-return&amp;quot;: 2,



        /*eslint-plugin-react*/

        &amp;quot;react/jsx-boolean-value&amp;quot;: 2,

        &amp;quot;react/jsx-quotes&amp;quot;: 2,

        &amp;quot;react/jsx-no-undef&amp;quot;: 2,

        &amp;quot;react/jsx-sort-props&amp;quot;: 0,

        &amp;quot;react/jsx-sort-prop-types&amp;quot;: 0,

        &amp;quot;react/jsx-uses-react&amp;quot;: 2,

        &amp;quot;react/jsx-uses-vars&amp;quot;: 2,

        &amp;quot;react/no-did-mount-set-state&amp;quot;: 2,

        &amp;quot;react/no-did-update-set-state&amp;quot;: 2,

        &amp;quot;react/no-multi-comp&amp;quot;: 2,

        &amp;quot;react/no-unknown-property&amp;quot;: 1,

        &amp;quot;react/prop-types&amp;quot;: 1,

        &amp;quot;react/react-in-jsx-scope&amp;quot;: 2,

        &amp;quot;react/self-closing-comp&amp;quot;: 2,

        &amp;quot;react/wrap-multilines&amp;quot;: 0

    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AJAX: XHR, jQuery and Fetch API</title>
      <link>http://nodejh.com/postback/ajax-xhr-jquery-and-fetch-api/</link>
      <pubDate>Mon, 26 Sep 2016 19:58:03 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/ajax-xhr-jquery-and-fetch-api/</guid>
      <description>

&lt;p&gt;本文详细讲述如何使用原生 JS、jQuery 和 Fetch 来实现 AJAX。&lt;/p&gt;

&lt;p&gt;AJAX 即 Asynchronous JavaScript and XML，异步的 JavaScript 和 XML。使用 AJAX 可以无刷新地向服务端发送请求接收服务端响应，并更新页面。&lt;/p&gt;

&lt;h2 id=&#34;一-原生-js-实现-ajax&#34;&gt;一、原生 JS 实现 AJAX&lt;/h2&gt;

&lt;p&gt;JS 实现 AJAX 主要基于浏览器提供的 XMLHttpRequest（XHR）类，所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。&lt;/p&gt;

&lt;h4 id=&#34;1-获取xmlhttprequest对象&#34;&gt;1. 获取XMLHttpRequest对象&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 获取XMLHttpRequest对象
var xhr = new XMLHttpRequest();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要兼容老版本的 IE (IE5, IE6) 浏览器，则可以使用 ActiveX 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-发送一个-http-请求&#34;&gt;2. 发送一个 HTTP 请求&lt;/h4&gt;

&lt;p&gt;接下来，我们需要打开一个URL，然后发送这个请求。分别要用到 XMLHttpRequest 的 open() 方法和 save() 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET
var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
if (xhr) {
  xhr.open(&#39;GET&#39;, &#39;/api?username=admin&amp;amp;password=root&#39;, true);
  xhr.send(null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// POST
var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
if (xhr) {
  xhr.open(&#39;POST&#39;, &#39;/api&#39;, true);
  // 设置 Content-Type 为 application/x-www-form-urlencoded
  // 以表单的形式传递数据
  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);
  xhr.send(&#39;username=admin&amp;amp;password=root&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 方法有三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open()&lt;/code&gt; 的第一个参数是 HTTP 请求方式 – GET，POST，HEAD 或任何服务器所支持的您想调用的方式。按照HTTP规范，该参数要大写；否则，某些浏览器(如Firefox)可能无法处理请求。有关HTTP请求方法的详细信息可参考 &lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&#34;&gt;https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第二个参数是请求页面的 URL。由于同源策略（Same origin policy）该页面不能为第三方域名的页面。同时一定要保证在所有的页面中都使用准确的域名，否则调用 &lt;code&gt;open()&lt;/code&gt; 会得到 &lt;code&gt;permission denied&lt;/code&gt; 的错误提示。&lt;/li&gt;
&lt;li&gt;第三个参数设置请求是否为异步模式。如果是 &lt;code&gt;TRUE&lt;/code&gt;，JavaScript 函数将继续执行，而不等待服务器响应。这就是 AJAX 中的 A。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果第一个参数是 &lt;code&gt;GET&lt;/code&gt;，则可以直接将参数放在 url 后面，如：&lt;code&gt;http://nodejh.com/api?name=admint&amp;amp;password=root&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果第一个参数是 &lt;code&gt;POST&lt;/code&gt;，则需要将参数写在 send() 方法里面。send() 方法的参数可以是任何想送给服务器的数据。这时数据要以字符串的形式送给服务器，如：&lt;code&gt;name=admint&amp;amp;password=root&lt;/code&gt;。或者也可以传递 JSON 格式的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 设置 Content-Type 为 application/json
xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);
// 传递 JSON 字符串
xhr.send(JSON.stringify({ username:&#39;admin&#39;, password:&#39;root&#39; }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不设置请求头，原生 AJAX 会默认使用 Content-Type 是 &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; 的方式发送数据。&lt;/p&gt;

&lt;p&gt;关于 Content-Type 更详细的内容，将在以后的文章中解释说明。&lt;/p&gt;

&lt;h4 id=&#34;3-处理服务器的响应&#34;&gt;3. 处理服务器的响应&lt;/h4&gt;

&lt;p&gt;当发送请求时，我们需要指定如何处理服务器的响应，我们需要用到 onreadystatechange 属性来检测服务器的响应状态。使用 onreadystatechange 有两种方式，一是直接 onreadystatechange 属性指定一个可调用的函数名，二是使用一个匿名函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 方法一 指定可调用的函数
xhr.onreadystatechange = onReadyStateChange;
function onReadyStateChange() {
  // do something
}

// 方法二 使用匿名函数
xhr.onreadystatechange = function(){
    // do the thing
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们需要在内部利用 readyState 属性来获取当前的状态，当 readyState 的值为 4，就意味着一个完整的服务器响应已经收到了，接下来就可以处理该响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// readyState的取值如下
// 0 (未初始化)
// 1 (正在装载)
// 2 (装载完毕)
// 3 (交互中)
// 4 (完成)
if (xhr.readyState === 4) {
    // everything is good, the response is received
} else {
    // still not ready
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// POST
var xhr;
if (window.XMLHttpRequest) { // Mozilla, Safari...
  xhr = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    xhr = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;);
  } catch (e) {
    try {
      xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    } catch (e) {}
  }
}
if (xhr) {
  xhr.onreadystatechange = onReadyStateChange;
  xhr.open(&#39;POST&#39;, &#39;/api&#39;, true);
  // 设置 Content-Type 为 application/x-www-form-urlencoded
  // 以表单的形式传递数据
  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);
  xhr.send(&#39;username=admin&amp;amp;password=root&#39;);
}


// onreadystatechange 方法
function onReadyStateChange() {
  // 该函数会被调用四次
  console.log(xhr.readyState);
  if (xhr.readyState === 4) {
    // everything is good, the response is received
    if (xhr.status === 200) {
      console.log(xhr.responseText);
    } else {
      console.log(&#39;There was a problem with the request.&#39;);
    }
  } else {
    // still not ready
    console.log(&#39;still not ready...&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然我们可以用onload来代替onreadystatechange等于4的情况，因为onload只在状态为4的时候才被调用，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xhr.onload = function () {    // 调用onload
    if (xhr.status === 200) {    // status为200表示请求成功
        console.log(&#39;执行成功&#39;);
    } else {
        console.log(&#39;执行出错&#39;);
    }   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而需要注意的是，IE对 onload 属性的支持并不友好。除了 onload 还有以下几个属性也可以用来监测响应状态：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onloadstart&lt;/li&gt;
&lt;li&gt;onprogress&lt;/li&gt;
&lt;li&gt;onabort&lt;/li&gt;
&lt;li&gt;ontimeout&lt;/li&gt;
&lt;li&gt;onerror&lt;/li&gt;
&lt;li&gt;onloadend&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-jquery-实现-ajax&#34;&gt;二、 jQuery 实现 AJAX&lt;/h2&gt;

&lt;p&gt;jQuery 作为一个使用人数最多的库，其 AJAX 很好的封装了原生 AJAX 的代码，在兼容性和易用性方面都做了很大的提高，让 AJAX 的调用变得非常简单。下面便是一段简单的 jQuery 的 AJAX 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
  method: &#39;POST&#39;,
  url: &#39;/api&#39;,
  data: { username: &#39;admin&#39;, password: &#39;root&#39; }
})
  .done(function(msg) {
    alert( &#39;Data Saved: &#39; + msg );
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比原生 AJAX 的实现，使用 jQuery 就异常简单了。当然我们平时用的最多的，是下面两种更简单的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET
$.get(&#39;/api&#39;, function(res) {
  // do something
});

// POST
var data = {
  username: &#39;admin&#39;,
  password: &#39;root&#39;
};
$.post(&#39;/api&#39;, data, function(res) {
  // do something
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-fetch-api&#34;&gt;三、Fetch API&lt;/h2&gt;

&lt;p&gt;使用 jQuery 虽然可以大大简化 XMLHttpRequest 的使用，但 XMLHttpRequest 本质上但并不是一个设计优良的 API：
+ 不符合关注分离（Separation of Concerns）的原则
+ 配置和调用方式非常混乱
+ 使用事件机制来跟踪状态变化
+ 基于事件的异步模型没有现代的 Promise，generator/yield，async/await 友好&lt;/p&gt;

&lt;p&gt;Fetch API 旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 &lt;code&gt;fetch()&lt;/code&gt; 这个实用的方法来获取网络资源。&lt;/p&gt;

&lt;p&gt;Fetch 的浏览器兼容图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nodejh.com/images/ajax-js-jquery-and-fetch-api-0.png&#34; alt=&#34;ajax-js-jquery-and-fetch-api-0.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于 IE8 是 ES3，需要引入 ES5 的 polyfill: &lt;a href=&#34;https://github.com/es-shims/es5-shim&#34;&gt;es5-shim, es5-sham&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入 Promise 的 polyfill: &lt;a href=&#34;https://github.com/stefanpenner/es6-promise&#34;&gt;es6-promise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入 fetch 探测库：&lt;a href=&#34;https://github.com/camsong/fetch-detector&#34;&gt;fetch-detector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入 fetch 的 polyfill: &lt;a href=&#34;https://github.com/camsong/fetch-ie8&#34;&gt;fetch-ie8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可选：如果你还使用了 jsonp，引入 &lt;a href=&#34;https://github.com/camsong/fetch-jsonp&#34;&gt;fetch-jsonp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可选：开启 Babel 的 runtime 模式，现在就使用 async/await&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-一个使用-fetch-的例子&#34;&gt;1. 一个使用 Fetch 的例子&lt;/h4&gt;

&lt;p&gt;先看一个简单的 Fetch API 的例子 🌰 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetch(&#39;/api&#39;).then(function(response) {
  return response.json();
}).then(function(data) {
  console.log(data);
}).catch(function(error) {
  console.log(&#39;Oops, error: &#39;, error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 ES6 的箭头函数后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fetch(&#39;/api&#39;).then(response =&amp;gt; response.json())
  .then(data =&amp;gt; console.log(data))
  .catch(error =&amp;gt; console.log(&#39;Oops, error: &#39;, error))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出使用Fetch后我们的代码更加简洁和语义化，链式调用的方式也使其更加流畅和清晰。但这种基于 Promise 的写法还是有 Callback 的影子，我们还可以用 &lt;code&gt;async/await&lt;/code&gt; 来做最终优化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async function() {
  try {
    let response = await fetch(url);
    let data = response.json();
    console.log(data);
  } catch (error) {
    console.log(&#39;Oops, error: &#39;, error);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;await&lt;/code&gt; 后，写代码就更跟同步代码一样。&lt;code&gt;await&lt;/code&gt; 后面可以跟 Promise 对象，表示等待 Promise &lt;code&gt;resolve()&lt;/code&gt; 才会继续向下执行，如果 Promise 被 &lt;code&gt;reject()&lt;/code&gt; 或抛出异常则会被外面的 &lt;code&gt;try...catch&lt;/code&gt; 捕获。&lt;/p&gt;

&lt;p&gt;Promise，generator/yield，await/async 都是现在和未来 JS 解决异步的标准做法，可以完美搭配使用。这也是使用标准 Promise 一大好处。&lt;/p&gt;

&lt;h4 id=&#34;2-使用-fetch-的注意事项&#34;&gt;2. 使用 Fetch 的注意事项&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Fetch 请求默认是不带 cookie，需要设置 &lt;code&gt;fetch(url, {credentials: &#39;include&#39;})&lt;/code&gt;`&lt;/li&gt;
&lt;li&gt;服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来将上面基于 XMLHttpRequest 的 AJAX 用 Fetch 改写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var options = {
    method: &#39;POST&#39;,
    headers: {
      &#39;Accept&#39;: &#39;application/json&#39;,
      &#39;Content-Type&#39;: &#39;application/json&#39;
    },
    body: JSON.stringify({ username: &#39;admin&#39;, password: &#39;root&#39; }),
    credentials: &#39;include&#39;
  };

fetch(&#39;/api&#39;, options).then(response =&amp;gt; response.json())
  .then(data =&amp;gt; console.log(data))
  .catch(error =&amp;gt; console.log(&#39;Oops, error: &#39;, error))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Start React with Webpack</title>
      <link>http://nodejh.com/postback/Start-React-with-Webpack/</link>
      <pubDate>Fri, 09 Sep 2016 04:11:13 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Start-React-with-Webpack/</guid>
      <description>

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/nodejh/start-react-with-webpack react-sample
$ cd react-sample &amp;amp;&amp;amp; npm install
$ npm run dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开浏览器输入 &lt;code&gt;http://localhost:8080&lt;/code&gt;，并尝试随意修改一下 app 目录里面的代码，就能看到效果了。&lt;/p&gt;

&lt;p&gt;为了避免包版本问题导致程序不能运行，根目录下有一个 &lt;code&gt;npm-shrinkwrap.json&lt;/code&gt; 文件，这里面所有包的版本都是固定的。 &lt;code&gt;npm install&lt;/code&gt; 时首先会检查在根目录下有没有 &lt;code&gt;npm-shrinkwrap.json&lt;/code&gt;，如果 shrinkwrap 文件存在的话，npm 会使用它（而不是 &lt;code&gt;package.json&lt;/code&gt;）来确定安装的各个包的版本号信息。&lt;/p&gt;

&lt;h2 id=&#34;1-安装并配置-webpack&#34;&gt;1. 安装并配置 Webpack&lt;/h2&gt;

&lt;p&gt;首先创建并初始化一个项目目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir react-sample &amp;amp;&amp;amp; cd react-sample
$ npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 &lt;code&gt;webpack&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm i webpack --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后配置 &lt;code&gt;webpack.config.js&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 创建一个 webpack.config.js 文件
$ touch webpack.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;在该文件中加入下面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const webpack = require(&#39;webpack&#39;);
const path = require(&#39;path&#39;);

// 定义打包目录路径
const BUILD_DIR = path.resolve(__dirname, &#39;./build&#39;);
// 定义组件目录路径
const APP_DIR = path.resolve(__dirname, &#39;./app&#39;);

const config = {
  entry: `${APP_DIR}/index.jsx`, // 文件打包的入口点
  output: {
    path: BUILD_DIR, // 输出目录的绝对路径
    filename: &#39;bundle.js&#39;, // 输出的每个包的相对路径
  },
  resolve: {
    extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;], // 开启后缀名的自动补全
  },
};

module.exports = config;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个最基本的 webpack 配置文件。&lt;/p&gt;

&lt;p&gt;接下来在 &lt;code&gt;build/&lt;/code&gt; 目录中创建一个 &lt;code&gt;index.html&lt;/code&gt; 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Start React with Webpack&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot; /&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-配置加载器-babel-loader&#34;&gt;2. 配置加载器 babel-loader&lt;/h2&gt;

&lt;p&gt;加载器是把一个资源文件作为入参转换为另一个资源文件的 node.js 函数。&lt;/p&gt;

&lt;p&gt;由于我们写 React 的时候使用的是 JSX 语法和 ES6 语法，而浏览器并不完全支持它们。所以需要使用 &lt;a href=&#34;https://github.com/babel/babel-loader&#34;&gt;&lt;code&gt;babel-loader&lt;/code&gt;&lt;/a&gt; 来让 webpack 加载 JSX 和 ES6 的文件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;babel-loader&lt;/code&gt; 的主要作用如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nodejh.com/images/Start-React-with-Webpack-babel-loader.png&#34; alt=&#34;Babel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安装依赖包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm i babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;babel-preset-es2015&lt;/code&gt; 是转换 &lt;code&gt;ES6&lt;/code&gt; 的包；&lt;code&gt;babel-preset-react&lt;/code&gt; 是转换 JSX 的包。&lt;/p&gt;

&lt;p&gt;接下来需要修改 &lt;code&gt;webpack.config.js&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Existing Code ....
const config = {
  // Existing Code ....
  module: {
    loaders: [{
      test: /\.(js|jsx)$/,
      exclude: /(node_modules|bower_components)/,
      loader: &#39;babel-loader&#39;,
      query: {
        presets: [&#39;es2015&#39;, &#39;react&#39;]
      }
    }]
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-hello-react&#34;&gt;3. Hello React&lt;/h2&gt;

&lt;p&gt;安装 React：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm i react react-dom --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;app&lt;/code&gt; 目录下新建一个 &lt;code&gt;index.jsx&lt;/code&gt; 文件，然后将下面的内容添加到 &lt;code&gt;index.jsx&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;

class App extends React.Component {
  render () {
    return &amp;lt;h1&amp;gt; Hello React!&amp;lt;/h1&amp;gt;;
  }
}

render(&amp;lt;App/&amp;gt;, document.getElementById(&#39;app&#39;));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，执行下面的命令打包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;webpack -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-w&lt;/code&gt; 参数表示持续监测项目目录，如果文件发生修改，则重新打包。&lt;/p&gt;

&lt;p&gt;打包完成后，将 &lt;code&gt;build/index.html&lt;/code&gt; 用浏览器打开，就能看到 &lt;code&gt;Hello React!&lt;/code&gt;，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nodejh.com/images/Start-React-with-Webpack-hello_world.png&#34; alt=&#34;hello_world.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-自动刷新和热加载&#34;&gt;4. 自动刷新和热加载&lt;/h2&gt;

&lt;p&gt;懒是第一生产力。每次写完代码，都要重新打包，重新刷新浏览器才能看到结果，显然很麻烦。&lt;/p&gt;

&lt;p&gt;那有没有能够自动刷新浏览器的方法呢？当然有，这个时候就需要 webpack-dev-server 这个包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install webpack-dev-server -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack-dev-server&lt;/code&gt; 提供了两种自动刷新模式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Iframe 模式&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不需要额外配置，只用修改路径&lt;/li&gt;
&lt;li&gt;应用被嵌入了一个 iframe 内部，页面顶部可以展示打包进度信息&lt;/li&gt;
&lt;li&gt;因为 Iframe 的关系，如果应用有多个页面，无法看到当前页面的 URL 信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;inline 模式&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要添加 &amp;ndash;inline 配置参数&lt;/li&gt;
&lt;li&gt;提示信息在控制台中和浏览器的console中显示&lt;/li&gt;
&lt;li&gt;页面的 URL 改变，可以在浏览器地址栏看见&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来启动 webpack-dev-server：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ webpack-dev-server --inline --hot --content-base ./build/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--hot&lt;/code&gt; 参数就是热加载，即在不刷新浏览器的条件下，应用最新的代码更新。在浏览器中可能看到这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[HMR] Waiting for update signal from WDS...
[WDS] Hot Module Replacement enabled.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--content-base ./&lt;/code&gt; 参数表示将当前目录作为 server 根目录。命令启动后，会在 8080 端口创建一个 HTTP 服务，通过访问 &lt;code&gt;http://localhost:8080/index.html&lt;/code&gt; 就可以访问我们的项目了，并且修改了项目中的代码后，浏览器会自动刷新并实现热加载。&lt;/p&gt;

&lt;p&gt;当然，命令行输入这么长，还是不太方便，所以还有一种更简单的方式，在 &lt;code&gt;package.json&lt;/code&gt; 中配置 webpack develop server：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Existing Code ....
&amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --inline --hot --content-base ./build/&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后通过 &lt;code&gt;npm start dev&lt;/code&gt; 来启动即可。&lt;/p&gt;

&lt;h2 id=&#34;5-添加一个新的组件&#34;&gt;5. 添加一个新的组件&lt;/h2&gt;

&lt;p&gt;在 &lt;code&gt;app&lt;/code&gt; 目录中新建一个 &lt;code&gt;AwesomeComponent.jsx&lt;/code&gt; 文件，并添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component } from &#39;react&#39;;

class AwesomeComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      likesCount: 0
    };
    this.onLike = this.onLike.bind(this);
  }


  onLike() {
    let newLikesCount = this.state.likesCount + 1;
    this.setState({
      likesCount: newLikesCount
    });
  }


  render() {
    return (
      &amp;lt;div&amp;gt;
        Likes: &amp;lt;span&amp;gt;{this.state.likesCount}&amp;lt;/span&amp;gt;
        &amp;lt;div&amp;gt;
          &amp;lt;button onClick={this.onLike}&amp;gt;Like Me&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}


export default AwesomeComponent;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改 &lt;code&gt;index.jsx&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
import AwesomeComponent from &#39;./AwesomeComponent.jsx&#39;;
// ...
class App extends React.Component {
  render () {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt; Hello React!&amp;lt;/p&amp;gt;
        &amp;lt;AwesomeComponent /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://nodejh.com/images/Start-React-with-Webpack-like.png&#34; alt=&#34;like.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;update&#34;&gt;UPDATE&lt;/h2&gt;

&lt;h3 id=&#34;2016-10-15&#34;&gt;2016.10.15&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;更新 webpack-dev-server 的配置方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;设置-webpack-dev-server-old&#34;&gt;设置 webpack-dev-server (old)&lt;/h5&gt;

&lt;p&gt;上面我们直接通过浏览器浏览的 &lt;code&gt;html&lt;/code&gt; 文件，接下来我们需要利用 &lt;code&gt;webpack-dev-server&lt;/code&gt; 来创建一个 HTTP Server。&lt;/p&gt;

&lt;p&gt;首先安装 &lt;code&gt;webpack-dev-server&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm i webpack-dev-server --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;script&lt;/code&gt; 里面加入 &lt;code&gt;build&lt;/code&gt; 和 &lt;code&gt;dev&lt;/code&gt; 两个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --devtool eval --progress --colors --hot --content-base build&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器&lt;/li&gt;
&lt;li&gt;&amp;ndash;devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号&lt;/li&gt;
&lt;li&gt;&amp;ndash;progress - 显示合并代码进度&lt;/li&gt;
&lt;li&gt;&amp;ndash;colors - 命令行中显示颜色！&lt;/li&gt;
&lt;li&gt;&amp;ndash;content-base build - 指向设置的输出目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后就可以使用 &lt;code&gt;npm run dev&lt;/code&gt; 的命令来启动项目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm run dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器地址栏输入 &lt;code&gt;localhost:8080&lt;/code&gt; 即可看到页面。&lt;/p&gt;

&lt;p&gt;如果需要浏览器自动刷新，将 &lt;code&gt;webpack.config.js&lt;/code&gt; 中的 &lt;code&gt;entry: APP_DIR + &#39;/index.jsx&lt;/code&gt; 改为下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;entry: [
   &#39;webpack-dev-server/client?http://localhost:8080&#39;,
   &#39;webpack/hot/dev-server&#39;,
    APP_DIR + &#39;/index.jsx&#39;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，每次当代码发生变化之后，webpack 会自动重新打包，浏览器也会自动刷新页面。&lt;/p&gt;

&lt;h3 id=&#34;2016-11-19-更新&#34;&gt;2016.11.19 更新&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用 ES6 语法编写 webpack.config.js&lt;/li&gt;
&lt;li&gt;修改 babel-loader 加载器的配置方法：将添加 &lt;code&gt;.babelrc&lt;/code&gt; 文件改为在 webpack.config.js 中配置&lt;/li&gt;
&lt;li&gt;🐛：webpack-dev-server &amp;ndash;inline &amp;ndash;hot &amp;ndash;content-base ./build/ ➡️ webpack-dev-server &amp;ndash;inline &amp;ndash;hot &amp;ndash;content-base ./build/&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;babel-loader-加载器的配置方法-old&#34;&gt;babel-loader 加载器的配置方法(old)&lt;/h5&gt;

&lt;p&gt;接下来需要配置 babel-loader，告诉 webpack 我们使用了 ES6 和 JSX 插件。先通过touch .babelrc 创建一个名为 .babelrc 的配置文件。然后加入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;presets&amp;quot; : [&amp;quot;es2015&amp;quot;, &amp;quot;react&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再修改 webpack.config.js，使 webpack 在打包的时候，使用 babel-loader：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Existing Code ....
var config = {
  // Existing Code ....
  module: {
    loaders : [
      {
        test : /\.jsx?/,
        include : APP_DIR,
        loader : &#39;babel&#39;
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;自动刷新和热加在的配置-old-wrong&#34;&gt;自动刷新和热加在的配置(old, wrong)&lt;/h5&gt;

&lt;p&gt;当然，命令行输入这么长，还是不太方便，所以还有一种更简单的方式，直接在 &lt;code&gt;webpack.cofig.js&lt;/code&gt; 中配置 webpack develop server：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  entry: {
    // ...      
  },
  // ...
  devServer: {
    hot: true,
    inline: true
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Install Opencv3 for Python3.5 on Mac OS X</title>
      <link>http://nodejh.com/postback/install-opencv3-for-python3-5-on-mac-os-x/</link>
      <pubDate>Mon, 01 Aug 2016 21:17:51 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/install-opencv3-for-python3-5-on-mac-os-x/</guid>
      <description>

&lt;h2 id=&#34;通过-homebrew-安装-opencv&#34;&gt;通过 homebrew 安装 opencv&lt;/h2&gt;

&lt;p&gt;通过 homebrew 安装在 Mac OS X 上安装为 Python3.5 安装 Opencv3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install opencv3 --with-python3
......
......
This formula is keg-only, which means it was not symlinked into /usr/local.

opencv3 and opencv install many of the same files.

Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you&#39;ll need to add to your
build variables:

    LDFLAGS:  -L/usr/local/opt/opencv3/lib
    CPPFLAGS: -I/usr/local/opt/opencv3/include

==&amp;gt; Summary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，会有如上提示。接下来需要做的事，将 &lt;code&gt;opencv3&lt;/code&gt; 的 &lt;code&gt;site-packegs&lt;/code&gt; 链接到 &lt;code&gt;Python3&lt;/code&gt; 的 &lt;code&gt;site-packegs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo /usr/local/opt/opencv3/lib/python3.5/site-packages &amp;gt;&amp;gt; /usr/local/lib/python3.5/site-packages/opencv3.pth
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检查是否安装成功&#34;&gt;检查是否安装成功&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ python
&amp;gt;&amp;gt;&amp;gt; import cv2
&amp;gt;&amp;gt;&amp;gt; cv2.__version__
&#39;3.1.0&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Troubleshoot MySQL Start Error</title>
      <link>http://nodejh.com/postback/Troubleshoot-MySQL-Start-Error/</link>
      <pubDate>Sun, 31 Jul 2016 17:05:44 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Troubleshoot-MySQL-Start-Error/</guid>
      <description>

&lt;p&gt;今天使用 MySQL 的时候，莫名奇妙除了很多问题。在 Google 和 StackOverflow 搜索了一大堆，也没有找到很好解决办法。Anyway，最终机智的我还是把问题解决。&lt;/p&gt;

&lt;p&gt;在此记录下整个排错过程。&lt;/p&gt;

&lt;h4 id=&#34;0-系统环境&#34;&gt;0. 系统环境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;操作系统 OS X EI Caption 10.11.6 (15G31)&lt;/li&gt;
&lt;li&gt;MySQL 5.7.13&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/local/mysql/bin&lt;/code&gt; 和 &lt;code&gt;/usr/local/mysql/support-files&lt;/code&gt; 都已经加入到了系统环境变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-进入-mysql-控制台报错&#34;&gt;1. 进入 MySQL 控制台报错&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 使用 mysql 命令进入 mysql 控制台
$ mysql -uroot -p
Enter password:
ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现这个错误，第一时间想到的原因就是 MySQL 并没有启动。为了验证这个猜测，所以我们接下来看看 MySQL 的运行情况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mysql.server status
/usr/local/mysql/support-files/mysql.server: line 365: pidof: command not found
 ERROR! MySQL is not running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现， MySQL 没有运行。&lt;/p&gt;

&lt;p&gt;这里使用的是 &lt;code&gt;mysql.server status&lt;/code&gt; 命令来查看 MySQL 的运行状态。如果你没有将该命令加入到系统环境变量，则需要加上相应的路径才行，不然会有类似于 &lt;code&gt;zsh: command not found: mysql.server&lt;/code&gt; 的错误，也就是说，没有这个命令。&lt;/p&gt;

&lt;p&gt;如果没有将 MySQL 相应命令加入系统环境变量，一般需要这么来启动 MySQL：&lt;code&gt;/usr/local/mysql/support-files/mysql.server status&lt;/code&gt;，进入 MySQL 控台则需要这样：&lt;code&gt;/usr/local/mysql/bin/mysql -uroot -p&lt;/code&gt;。也就是在 &lt;code&gt;mysql.server&lt;/code&gt; 或 &lt;code&gt;mysql&lt;/code&gt; 等命令前加上路径。&lt;/p&gt;

&lt;h4 id=&#34;2-mysql-启动报错&#34;&gt;2. MySQL 启动报错&lt;/h4&gt;

&lt;p&gt;既然 MySQL 没有运行，那么我们肯定要启动 MySQL。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mysql.server start
Starting MySQL
. ERROR! The server quit without updating PID file (/usr/local/mysql/data/jh.local.pid).
$ mysql.server status
/usr/local/mysql/support-files/mysql.server: line 365: pidof: command not found
 ERROR! MySQL is not running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动报错了。会不会是权限不够呢？于是我们再试试使用 &lt;code&gt;sudo&lt;/code&gt; 来启动 MySQL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Starting MySQL
...........................
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;...&lt;/code&gt; 一直在增长，MySQL 一直是正在启动，但就是无法启动成功。&lt;/p&gt;

&lt;h4 id=&#34;3-排查-mysql-启动报错原因&#34;&gt;3. 排查 MySQL 启动报错原因&lt;/h4&gt;

&lt;p&gt;既然 MySQL 启动报错了，那么我们可以通过查看一些日志来推断 MySQL 的报错原因。
在 MySQL 的安装目录里面，有一个 &lt;code&gt;data&lt;/code&gt; 目录 （&lt;code&gt;/usr/local/mysql/data&lt;/code&gt;），这里吗有一个名为 &lt;code&gt;your_computer_name.local.err&lt;/code&gt; 的文件（例如我的该文件名为 &lt;code&gt;jh.local.err&lt;/code&gt; ），这个文件里面记录了 MySQL 启动的详细日志信息。&lt;/p&gt;

&lt;p&gt;为了更准地得到我们想要的信息，我们可以先删掉改文件，然后再启动 MySQL。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm /usr/local/mysql/data/jh.local.err
$ sudo mysql.server start
Starting MySQL
..................
# 然后 Ctrl+C 停止进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，再来看看 &lt;code&gt;jh.local.err&lt;/code&gt; 里面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo tail /usr/local/mysql/data/jh.local.err
2016-07-31T15:31:35.414440Z 0 [ERROR] InnoDB: Unable to lock ./ibdata1 error: 35
2016-07-31T15:31:35.414531Z 0 [Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.
2016-07-31T15:31:36.417804Z 0 [ERROR] InnoDB: Unable to lock ./ibdata1 error: 35
2016-07-31T15:31:36.418940Z 0 [Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.
2016-07-31T15:31:37.422609Z 0 [ERROR] InnoDB: Unable to lock ./ibdata1 error: 35
2016-07-31T15:31:37.422654Z 0 [Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.
2016-07-31T15:31:38.427437Z 0 [ERROR] InnoDB: Unable to lock ./ibdata1 error: 35
2016-07-31T15:31:38.427670Z 0 [Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.
2016-07-31T15:31:39.431165Z 0 [ERROR] InnoDB: Unable to lock ./ibdata1 error: 35
2016-07-31T15:31:39.431205Z 0 [Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行就出现了 &lt;code&gt;[ERROR] InnoDB: Unable to lock ./ibdata1 error: 35&lt;/code&gt;。然后第二行有个 &lt;code&gt;[Note] InnoDB: Check that you do not already have another mysqld process using the same InnoDB data or log files.&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;大概意思就是，启动 MySQL 的进程无法给 &lt;code&gt;ibdata1&lt;/code&gt; 这个文件加锁。可能是因为有其他 &lt;code&gt;mysqld&lt;/code&gt; 进程已经在使用该文件了。&lt;/p&gt;

&lt;p&gt;然后后面一直重复这两行。所以我们大概可以猜测，当我们使用 &lt;code&gt;sudo mysql.server start&lt;/code&gt; 这个命令来启动 MySQL 的时候，MySQL 一直在尝试启动，但由于进程占用，一直无法启动成功。&lt;/p&gt;

&lt;h4 id=&#34;4-查看-mysqld-进程&#34;&gt;4. 查看 mysqld 进程&lt;/h4&gt;

&lt;p&gt;既然可能是 &lt;code&gt;mysqld&lt;/code&gt; 进程已经启动，那么就列出 &lt;code&gt;mysqld&lt;/code&gt; 的进程看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps xa | grep mysqld
8238   ??  Ss     0:03.74 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid
10291 s003  R+     0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然是有进程启动了，那么我们结束该进程，再重新启动 MySQL  试试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo kill 8238
$ sudo mysql.server start
Starting MySQL
..................
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而还是和之前一样的情况。再看看进程启动情况？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10341   ??  Ss     0:00.38 /usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err --pid-file=/usr/local/mysql/data/mysqld.local.pid
10343 s003  R+     0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mysqld&lt;/code&gt; 的进程依然存在，只是进程 ID 由之前的 &lt;code&gt;8238&lt;/code&gt; 变成了 &lt;code&gt;10341&lt;/code&gt;。多试几次，就会发现，当我们 kill 掉 &lt;code&gt;mysqld&lt;/code&gt; 的进程后，它会自动重启。&lt;/p&gt;

&lt;h4 id=&#34;5-查看进程占用文件&#34;&gt;5. 查看进程占用文件&lt;/h4&gt;

&lt;p&gt;为了弄清楚已经启动的 &lt;code&gt;mysqld&lt;/code&gt; 进程到底是为什么重启，我们可以先看看进程打开了哪些文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lsof -c mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么都没有。&lt;code&gt;lsof&lt;/code&gt; 只会列出当前用户启动的进程打开的文件。那么加上 &lt;code&gt;sudo&lt;/code&gt; 试试？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lsof -c mysqld
COMMAND   PID   USER   FD     TYPE             DEVICE  SIZE/OFF     NODE NAME
mysqld  10634 _mysql  cwd      DIR                1,4       510 38686058 /usr/local/mysql-5.7.13-osx10.11-x86_64/data
mysqld  10634 _mysql  txt      REG                1,4  30794000 38685611 /usr/local/mysql-5.7.13-osx10.11-x86_64/bin/mysqld
mysqld  10634 _mysql  txt      REG                1,4    643792 38194604 /usr/lib/dyld
mysqld  10634 _mysql  txt      REG                1,4 558201098 39151946 /private/var/db/dyld/dyld_shared_cache_x86_64h
mysqld  10634 _mysql    0r     CHR                3,2       0t0      302 /dev/null
mysqld  10634 _mysql    1w     REG                1,4     71906 39198339 /usr/local/mysql-5.7.13-osx10.11-x86_64/data/mysqld.local.err
mysqld  10634 _mysql    2w     REG                1,4     71906 39198339 /usr/local/mysql-5.7.13-osx10.11-x86_64/data/mysqld.local.err
mysqld  10634 _mysql    3u  KQUEUE                                       count=0, state=0xa
.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然 &lt;code&gt;mysqld&lt;/code&gt; 打开了很多文件！说明 &lt;code&gt;mysqld&lt;/code&gt; 这个进程真实存在，并且占用了 MySQL 文件，而且是以 &lt;code&gt;root&lt;/code&gt; 权限运行的。&lt;/p&gt;

&lt;h4 id=&#34;6-mysql-到底为何而启动&#34;&gt;6. MySQL 到底为何而启动&lt;/h4&gt;

&lt;p&gt;继续推断，&lt;code&gt;root&lt;/code&gt; 权限启动，并且自动重启，那估计和系统启动有关了。&lt;/p&gt;

&lt;p&gt;在 Linux 系统下，&lt;code&gt;/etc/rc.*&lt;/code&gt; 或者 &lt;code&gt;/etc/init&lt;/code&gt; 目录下包含着系统里各个服务启动和停止的脚本，而 OS X 中则是由 &lt;code&gt;launchd&lt;/code&gt; 做进程的管理和控制。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;launchd&lt;/code&gt;  是OS X 从 10.4开始引入，用于用于初始化系统环境的关键进程，它是内核装载成功之后在OS环境下启动的第一个进程。采用这种方式配置启动进程，只需要一个 &lt;code&gt;plist&lt;/code&gt; 文件。&lt;code&gt;/Library/LaunchDaemons&lt;/code&gt; 目录下的 &lt;code&gt;plist&lt;/code&gt; 文件都是系统启动后立即启动进程。使用 &lt;code&gt;launchctl&lt;/code&gt; 命令加载/卸载 &lt;code&gt;plist&lt;/code&gt; 文件，加载配置文件后，程序启动，卸载配置文件后程序关闭。&lt;/p&gt;

&lt;p&gt;进入 &lt;code&gt;/Library/LaunchDaemons&lt;/code&gt; 查看一下，确实是有一个和 MySQL 相关的 &lt;code&gt;plist&lt;/code&gt; 文件 &lt;code&gt;com.oracle.oss.mysql.mysqld.plist&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么卸载该文件，然后再查看进程，验证是不是因为该 &lt;code&gt;plist&lt;/code&gt;，所以 &lt;code&gt;mysqld&lt;/code&gt; 才会不断重启：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo launchctl unload -w /Library/LaunchDaemons/com.oracle.oss.mysql.mysqld.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看进程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps xa | grep mysqld
10924 s005  S+     0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然 &lt;code&gt;mysqld&lt;/code&gt; 进程已经不存在了。说明推测是正确的，&lt;code&gt;mysqld&lt;/code&gt; 之所以会以 &lt;code&gt;root&lt;/code&gt; 权限启动，就是因为有一个启动 &lt;code&gt;mysqld&lt;/code&gt; 的 &lt;code&gt;plist&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;p&gt;因为是修通了系统的进程启动管理配置，所以需要重启一下，&lt;code&gt;launchd&lt;/code&gt; 才会在下次启动中生效。&lt;/p&gt;

&lt;p&gt;重启后，再通过 &lt;code&gt;mysql.server&lt;/code&gt;  来启动 MySQL，就会发现一切正常了！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mysql.server start
Password:
Starting MySQL
. SUCCESS!
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;7-总结&#34;&gt;7. 总结&lt;/h4&gt;

&lt;p&gt;加载 &lt;code&gt;plist&lt;/code&gt; 配置的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo launchctl load -w /Library/LaunchDaemons/com.oracle.oss.mysql.mysqld.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卸载 &lt;code&gt;plist&lt;/code&gt; 配置的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo launchctl unload -w /Library/LaunchDaemons/com.oracle.oss.mysql.mysqld.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以折腾了那么久，其实就只是因为 OS X 特殊的启动管理机制造成的 &lt;code&gt;mysqld&lt;/code&gt; 自动启动并占用进程，造成我们期望的 MySQL 启动方式没有正常运行。&lt;/p&gt;

&lt;p&gt;卸载掉 &lt;code&gt;plsit&lt;/code&gt; 配置并重启系统就好了！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use Nginx Reverse Proxy Node.js</title>
      <link>http://nodejh.com/postback/Use-Nginx-Reverse-Proxy-Nodejs/</link>
      <pubDate>Sat, 30 Apr 2016 17:19:20 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/Use-Nginx-Reverse-Proxy-Nodejs/</guid>
      <description>&lt;p&gt;一般来说使用 node.js 开发的 webapp 都不会是默认的80端口，以官方文档演示为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const http = require(&#39;http&#39;);

const hostname = &#39;127.0.0.1&#39;;
const port = 3000;

const server = http.createServer((req, res) =&amp;gt; {
  res.statusCode = 200;
  res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);
  res.end(&#39;Hello World\n&#39;);
});

server.listen(port, hostname, () =&amp;gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该例子使用的是 3000 端口，需要像 &lt;code&gt;localhost:3000&lt;/code&gt; 这样，域名（或IP）加上 &lt;code&gt;:port&lt;/code&gt; 才能访问。而一般 Web 应用都是监听的 80 端口。而普通应用一般只能监听 &lt;code&gt;1024&lt;/code&gt; 以上的端口号，监听 80 端口需要 root 权限。而且 node.js 监听了 80 端口后，像 nginx 这类 HTTP Server 就只能选择监听其他端口了。&lt;/p&gt;

&lt;p&gt;所以一般不使用 node.js 直接监听 80 端口，而是通过 nginx 来做反向代理。&lt;/p&gt;

&lt;p&gt;Nginx 的具体配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
upstream nodejs {
    server 127.0.0.1:3000;
    keepalive 64;
}

server {
    listen 80;
    # server_name 后面是域名，这里以 www.domain.com 为例
    server_name www.domain.com;
    # 日志
    access_log /var/log/nginx/test.log;
    location / {
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host  $http_host;
        proxy_set_header X-Nginx-Proxy true;
        proxy_set_header Connection &amp;quot;&amp;quot;;
        proxy_pass http://nodejs;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webstorm: Node.js core module source not configured</title>
      <link>http://nodejh.com/postback/webstorm-Node-js-core-module-source-not-configured/</link>
      <pubDate>Tue, 26 Apr 2016 23:37:35 +0800</pubDate>
      
      <guid>http://nodejh.com/postback/webstorm-Node-js-core-module-source-not-configured/</guid>
      <description>&lt;p&gt;在 Webstrom 中引入 Node.js 自带模块的时候，Webstorm 有如下错误提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node.js core module source not configured
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为没有配置 Webstorm 支持 Node.js 自带模块。&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;File | Settings | Languages &amp;amp; Frameworks | Node.js and NPM&lt;/code&gt;，在右侧面板会发现 &lt;code&gt;Node.js Core library is not enabled.&lt;/code&gt;，点击旁边的 &lt;code&gt;Enable&lt;/code&gt; 按钮然后再点击下面的 &lt;code&gt;OK&lt;/code&gt; 按钮即可。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>